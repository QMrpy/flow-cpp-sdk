// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: flow.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_flow_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_flow_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017003 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_flow_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_flow_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[50]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_flow_2eproto;
namespace flow {
namespace access {
class Account;
struct AccountDefaultTypeInternal;
extern AccountDefaultTypeInternal _Account_default_instance_;
class AccountKey;
struct AccountKeyDefaultTypeInternal;
extern AccountKeyDefaultTypeInternal _AccountKey_default_instance_;
class AccountResponse;
struct AccountResponseDefaultTypeInternal;
extern AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
class Account_ContractsEntry_DoNotUse;
struct Account_ContractsEntry_DoNotUseDefaultTypeInternal;
extern Account_ContractsEntry_DoNotUseDefaultTypeInternal _Account_ContractsEntry_DoNotUse_default_instance_;
class Block;
struct BlockDefaultTypeInternal;
extern BlockDefaultTypeInternal _Block_default_instance_;
class BlockHeader;
struct BlockHeaderDefaultTypeInternal;
extern BlockHeaderDefaultTypeInternal _BlockHeader_default_instance_;
class BlockHeaderResponse;
struct BlockHeaderResponseDefaultTypeInternal;
extern BlockHeaderResponseDefaultTypeInternal _BlockHeaderResponse_default_instance_;
class BlockResponse;
struct BlockResponseDefaultTypeInternal;
extern BlockResponseDefaultTypeInternal _BlockResponse_default_instance_;
class BlockSeal;
struct BlockSealDefaultTypeInternal;
extern BlockSealDefaultTypeInternal _BlockSeal_default_instance_;
class Chunk;
struct ChunkDefaultTypeInternal;
extern ChunkDefaultTypeInternal _Chunk_default_instance_;
class Collection;
struct CollectionDefaultTypeInternal;
extern CollectionDefaultTypeInternal _Collection_default_instance_;
class CollectionGuarantee;
struct CollectionGuaranteeDefaultTypeInternal;
extern CollectionGuaranteeDefaultTypeInternal _CollectionGuarantee_default_instance_;
class CollectionResponse;
struct CollectionResponseDefaultTypeInternal;
extern CollectionResponseDefaultTypeInternal _CollectionResponse_default_instance_;
class Event;
struct EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class EventsResponse;
struct EventsResponseDefaultTypeInternal;
extern EventsResponseDefaultTypeInternal _EventsResponse_default_instance_;
class EventsResponse_Result;
struct EventsResponse_ResultDefaultTypeInternal;
extern EventsResponse_ResultDefaultTypeInternal _EventsResponse_Result_default_instance_;
class ExecuteScriptAtBlockHeightRequest;
struct ExecuteScriptAtBlockHeightRequestDefaultTypeInternal;
extern ExecuteScriptAtBlockHeightRequestDefaultTypeInternal _ExecuteScriptAtBlockHeightRequest_default_instance_;
class ExecuteScriptAtBlockIdRequest;
struct ExecuteScriptAtBlockIdRequestDefaultTypeInternal;
extern ExecuteScriptAtBlockIdRequestDefaultTypeInternal _ExecuteScriptAtBlockIdRequest_default_instance_;
class ExecuteScriptAtLatestBlockRequest;
struct ExecuteScriptAtLatestBlockRequestDefaultTypeInternal;
extern ExecuteScriptAtLatestBlockRequestDefaultTypeInternal _ExecuteScriptAtLatestBlockRequest_default_instance_;
class ExecuteScriptResponse;
struct ExecuteScriptResponseDefaultTypeInternal;
extern ExecuteScriptResponseDefaultTypeInternal _ExecuteScriptResponse_default_instance_;
class ExecutionResult;
struct ExecutionResultDefaultTypeInternal;
extern ExecutionResultDefaultTypeInternal _ExecutionResult_default_instance_;
class ExecutionResultForBlockIdResponse;
struct ExecutionResultForBlockIdResponseDefaultTypeInternal;
extern ExecutionResultForBlockIdResponseDefaultTypeInternal _ExecutionResultForBlockIdResponse_default_instance_;
class GetAccountAtBlockHeightRequest;
struct GetAccountAtBlockHeightRequestDefaultTypeInternal;
extern GetAccountAtBlockHeightRequestDefaultTypeInternal _GetAccountAtBlockHeightRequest_default_instance_;
class GetAccountAtLatestBlockRequest;
struct GetAccountAtLatestBlockRequestDefaultTypeInternal;
extern GetAccountAtLatestBlockRequestDefaultTypeInternal _GetAccountAtLatestBlockRequest_default_instance_;
class GetBlockByHeightRequest;
struct GetBlockByHeightRequestDefaultTypeInternal;
extern GetBlockByHeightRequestDefaultTypeInternal _GetBlockByHeightRequest_default_instance_;
class GetBlockByIdRequest;
struct GetBlockByIdRequestDefaultTypeInternal;
extern GetBlockByIdRequestDefaultTypeInternal _GetBlockByIdRequest_default_instance_;
class GetBlockHeaderByHeightRequest;
struct GetBlockHeaderByHeightRequestDefaultTypeInternal;
extern GetBlockHeaderByHeightRequestDefaultTypeInternal _GetBlockHeaderByHeightRequest_default_instance_;
class GetBlockHeaderByIdRequest;
struct GetBlockHeaderByIdRequestDefaultTypeInternal;
extern GetBlockHeaderByIdRequestDefaultTypeInternal _GetBlockHeaderByIdRequest_default_instance_;
class GetCollectionByIdRequest;
struct GetCollectionByIdRequestDefaultTypeInternal;
extern GetCollectionByIdRequestDefaultTypeInternal _GetCollectionByIdRequest_default_instance_;
class GetEventsForBlockIdsRequest;
struct GetEventsForBlockIdsRequestDefaultTypeInternal;
extern GetEventsForBlockIdsRequestDefaultTypeInternal _GetEventsForBlockIdsRequest_default_instance_;
class GetEventsForHeightRangeRequest;
struct GetEventsForHeightRangeRequestDefaultTypeInternal;
extern GetEventsForHeightRangeRequestDefaultTypeInternal _GetEventsForHeightRangeRequest_default_instance_;
class GetExecutionResultForBlockIdRequest;
struct GetExecutionResultForBlockIdRequestDefaultTypeInternal;
extern GetExecutionResultForBlockIdRequestDefaultTypeInternal _GetExecutionResultForBlockIdRequest_default_instance_;
class GetLatestBlockHeaderRequest;
struct GetLatestBlockHeaderRequestDefaultTypeInternal;
extern GetLatestBlockHeaderRequestDefaultTypeInternal _GetLatestBlockHeaderRequest_default_instance_;
class GetLatestBlockRequest;
struct GetLatestBlockRequestDefaultTypeInternal;
extern GetLatestBlockRequestDefaultTypeInternal _GetLatestBlockRequest_default_instance_;
class GetLatestProtocolStateSnapshotRequest;
struct GetLatestProtocolStateSnapshotRequestDefaultTypeInternal;
extern GetLatestProtocolStateSnapshotRequestDefaultTypeInternal _GetLatestProtocolStateSnapshotRequest_default_instance_;
class GetNetworkParametersRequest;
struct GetNetworkParametersRequestDefaultTypeInternal;
extern GetNetworkParametersRequestDefaultTypeInternal _GetNetworkParametersRequest_default_instance_;
class GetNetworkParametersResponse;
struct GetNetworkParametersResponseDefaultTypeInternal;
extern GetNetworkParametersResponseDefaultTypeInternal _GetNetworkParametersResponse_default_instance_;
class GetTransactionRequest;
struct GetTransactionRequestDefaultTypeInternal;
extern GetTransactionRequestDefaultTypeInternal _GetTransactionRequest_default_instance_;
class PingRequest;
struct PingRequestDefaultTypeInternal;
extern PingRequestDefaultTypeInternal _PingRequest_default_instance_;
class PingResponse;
struct PingResponseDefaultTypeInternal;
extern PingResponseDefaultTypeInternal _PingResponse_default_instance_;
class ProtocolStateSnapshotResponse;
struct ProtocolStateSnapshotResponseDefaultTypeInternal;
extern ProtocolStateSnapshotResponseDefaultTypeInternal _ProtocolStateSnapshotResponse_default_instance_;
class SendTransactionRequest;
struct SendTransactionRequestDefaultTypeInternal;
extern SendTransactionRequestDefaultTypeInternal _SendTransactionRequest_default_instance_;
class SendTransactionResponse;
struct SendTransactionResponseDefaultTypeInternal;
extern SendTransactionResponseDefaultTypeInternal _SendTransactionResponse_default_instance_;
class ServiceEvent;
struct ServiceEventDefaultTypeInternal;
extern ServiceEventDefaultTypeInternal _ServiceEvent_default_instance_;
class Timestamp;
struct TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
class Transaction;
struct TransactionDefaultTypeInternal;
extern TransactionDefaultTypeInternal _Transaction_default_instance_;
class TransactionProposalKey;
struct TransactionProposalKeyDefaultTypeInternal;
extern TransactionProposalKeyDefaultTypeInternal _TransactionProposalKey_default_instance_;
class TransactionResponse;
struct TransactionResponseDefaultTypeInternal;
extern TransactionResponseDefaultTypeInternal _TransactionResponse_default_instance_;
class TransactionResultResponse;
struct TransactionResultResponseDefaultTypeInternal;
extern TransactionResultResponseDefaultTypeInternal _TransactionResultResponse_default_instance_;
class TransactionSignature;
struct TransactionSignatureDefaultTypeInternal;
extern TransactionSignatureDefaultTypeInternal _TransactionSignature_default_instance_;
}  // namespace access
}  // namespace flow
PROTOBUF_NAMESPACE_OPEN
template<> ::flow::access::Account* Arena::CreateMaybeMessage<::flow::access::Account>(Arena*);
template<> ::flow::access::AccountKey* Arena::CreateMaybeMessage<::flow::access::AccountKey>(Arena*);
template<> ::flow::access::AccountResponse* Arena::CreateMaybeMessage<::flow::access::AccountResponse>(Arena*);
template<> ::flow::access::Account_ContractsEntry_DoNotUse* Arena::CreateMaybeMessage<::flow::access::Account_ContractsEntry_DoNotUse>(Arena*);
template<> ::flow::access::Block* Arena::CreateMaybeMessage<::flow::access::Block>(Arena*);
template<> ::flow::access::BlockHeader* Arena::CreateMaybeMessage<::flow::access::BlockHeader>(Arena*);
template<> ::flow::access::BlockHeaderResponse* Arena::CreateMaybeMessage<::flow::access::BlockHeaderResponse>(Arena*);
template<> ::flow::access::BlockResponse* Arena::CreateMaybeMessage<::flow::access::BlockResponse>(Arena*);
template<> ::flow::access::BlockSeal* Arena::CreateMaybeMessage<::flow::access::BlockSeal>(Arena*);
template<> ::flow::access::Chunk* Arena::CreateMaybeMessage<::flow::access::Chunk>(Arena*);
template<> ::flow::access::Collection* Arena::CreateMaybeMessage<::flow::access::Collection>(Arena*);
template<> ::flow::access::CollectionGuarantee* Arena::CreateMaybeMessage<::flow::access::CollectionGuarantee>(Arena*);
template<> ::flow::access::CollectionResponse* Arena::CreateMaybeMessage<::flow::access::CollectionResponse>(Arena*);
template<> ::flow::access::Event* Arena::CreateMaybeMessage<::flow::access::Event>(Arena*);
template<> ::flow::access::EventsResponse* Arena::CreateMaybeMessage<::flow::access::EventsResponse>(Arena*);
template<> ::flow::access::EventsResponse_Result* Arena::CreateMaybeMessage<::flow::access::EventsResponse_Result>(Arena*);
template<> ::flow::access::ExecuteScriptAtBlockHeightRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtBlockHeightRequest>(Arena*);
template<> ::flow::access::ExecuteScriptAtBlockIdRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtBlockIdRequest>(Arena*);
template<> ::flow::access::ExecuteScriptAtLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptAtLatestBlockRequest>(Arena*);
template<> ::flow::access::ExecuteScriptResponse* Arena::CreateMaybeMessage<::flow::access::ExecuteScriptResponse>(Arena*);
template<> ::flow::access::ExecutionResult* Arena::CreateMaybeMessage<::flow::access::ExecutionResult>(Arena*);
template<> ::flow::access::ExecutionResultForBlockIdResponse* Arena::CreateMaybeMessage<::flow::access::ExecutionResultForBlockIdResponse>(Arena*);
template<> ::flow::access::GetAccountAtBlockHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetAccountAtBlockHeightRequest>(Arena*);
template<> ::flow::access::GetAccountAtLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::GetAccountAtLatestBlockRequest>(Arena*);
template<> ::flow::access::GetBlockByHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockByHeightRequest>(Arena*);
template<> ::flow::access::GetBlockByIdRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockByIdRequest>(Arena*);
template<> ::flow::access::GetBlockHeaderByHeightRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockHeaderByHeightRequest>(Arena*);
template<> ::flow::access::GetBlockHeaderByIdRequest* Arena::CreateMaybeMessage<::flow::access::GetBlockHeaderByIdRequest>(Arena*);
template<> ::flow::access::GetCollectionByIdRequest* Arena::CreateMaybeMessage<::flow::access::GetCollectionByIdRequest>(Arena*);
template<> ::flow::access::GetEventsForBlockIdsRequest* Arena::CreateMaybeMessage<::flow::access::GetEventsForBlockIdsRequest>(Arena*);
template<> ::flow::access::GetEventsForHeightRangeRequest* Arena::CreateMaybeMessage<::flow::access::GetEventsForHeightRangeRequest>(Arena*);
template<> ::flow::access::GetExecutionResultForBlockIdRequest* Arena::CreateMaybeMessage<::flow::access::GetExecutionResultForBlockIdRequest>(Arena*);
template<> ::flow::access::GetLatestBlockHeaderRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestBlockHeaderRequest>(Arena*);
template<> ::flow::access::GetLatestBlockRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestBlockRequest>(Arena*);
template<> ::flow::access::GetLatestProtocolStateSnapshotRequest* Arena::CreateMaybeMessage<::flow::access::GetLatestProtocolStateSnapshotRequest>(Arena*);
template<> ::flow::access::GetNetworkParametersRequest* Arena::CreateMaybeMessage<::flow::access::GetNetworkParametersRequest>(Arena*);
template<> ::flow::access::GetNetworkParametersResponse* Arena::CreateMaybeMessage<::flow::access::GetNetworkParametersResponse>(Arena*);
template<> ::flow::access::GetTransactionRequest* Arena::CreateMaybeMessage<::flow::access::GetTransactionRequest>(Arena*);
template<> ::flow::access::PingRequest* Arena::CreateMaybeMessage<::flow::access::PingRequest>(Arena*);
template<> ::flow::access::PingResponse* Arena::CreateMaybeMessage<::flow::access::PingResponse>(Arena*);
template<> ::flow::access::ProtocolStateSnapshotResponse* Arena::CreateMaybeMessage<::flow::access::ProtocolStateSnapshotResponse>(Arena*);
template<> ::flow::access::SendTransactionRequest* Arena::CreateMaybeMessage<::flow::access::SendTransactionRequest>(Arena*);
template<> ::flow::access::SendTransactionResponse* Arena::CreateMaybeMessage<::flow::access::SendTransactionResponse>(Arena*);
template<> ::flow::access::ServiceEvent* Arena::CreateMaybeMessage<::flow::access::ServiceEvent>(Arena*);
template<> ::flow::access::Timestamp* Arena::CreateMaybeMessage<::flow::access::Timestamp>(Arena*);
template<> ::flow::access::Transaction* Arena::CreateMaybeMessage<::flow::access::Transaction>(Arena*);
template<> ::flow::access::TransactionProposalKey* Arena::CreateMaybeMessage<::flow::access::TransactionProposalKey>(Arena*);
template<> ::flow::access::TransactionResponse* Arena::CreateMaybeMessage<::flow::access::TransactionResponse>(Arena*);
template<> ::flow::access::TransactionResultResponse* Arena::CreateMaybeMessage<::flow::access::TransactionResultResponse>(Arena*);
template<> ::flow::access::TransactionSignature* Arena::CreateMaybeMessage<::flow::access::TransactionSignature>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace flow {
namespace access {

enum TransactionStatus : int {
  UNKNOWN = 0,
  PENDING = 1,
  FINALIZED = 2,
  EXECUTED = 3,
  SEALED = 4,
  EXPIRED = 5,
  TransactionStatus_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  TransactionStatus_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool TransactionStatus_IsValid(int value);
constexpr TransactionStatus TransactionStatus_MIN = UNKNOWN;
constexpr TransactionStatus TransactionStatus_MAX = EXPIRED;
constexpr int TransactionStatus_ARRAYSIZE = TransactionStatus_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* TransactionStatus_descriptor();
template<typename T>
inline const std::string& TransactionStatus_Name(T enum_t_value) {
  static_assert(::std::is_same<T, TransactionStatus>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function TransactionStatus_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    TransactionStatus_descriptor(), enum_t_value);
}
inline bool TransactionStatus_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, TransactionStatus* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<TransactionStatus>(
    TransactionStatus_descriptor(), name, value);
}
// ===================================================================

class PingRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.PingRequest) */ {
 public:
  inline PingRequest() : PingRequest(nullptr) {}
  ~PingRequest() override;
  explicit constexpr PingRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingRequest(const PingRequest& from);
  PingRequest(PingRequest&& from) noexcept
    : PingRequest() {
    *this = ::std::move(from);
  }

  inline PingRequest& operator=(const PingRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingRequest& operator=(PingRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingRequest* internal_default_instance() {
    return reinterpret_cast<const PingRequest*>(
               &_PingRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(PingRequest& a, PingRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(PingRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingRequest* New() const final {
    return new PingRequest();
  }

  PingRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PingRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.PingRequest";
  }
  protected:
  explicit PingRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.PingRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class PingResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.PingResponse) */ {
 public:
  inline PingResponse() : PingResponse(nullptr) {}
  ~PingResponse() override;
  explicit constexpr PingResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PingResponse(const PingResponse& from);
  PingResponse(PingResponse&& from) noexcept
    : PingResponse() {
    *this = ::std::move(from);
  }

  inline PingResponse& operator=(const PingResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline PingResponse& operator=(PingResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PingResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const PingResponse* internal_default_instance() {
    return reinterpret_cast<const PingResponse*>(
               &_PingResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(PingResponse& a, PingResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(PingResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PingResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline PingResponse* New() const final {
    return new PingResponse();
  }

  PingResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<PingResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PingResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const PingResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PingResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.PingResponse";
  }
  protected:
  explicit PingResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.PingResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class BlockHeaderResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockHeaderResponse) */ {
 public:
  inline BlockHeaderResponse() : BlockHeaderResponse(nullptr) {}
  ~BlockHeaderResponse() override;
  explicit constexpr BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeaderResponse(const BlockHeaderResponse& from);
  BlockHeaderResponse(BlockHeaderResponse&& from) noexcept
    : BlockHeaderResponse() {
    *this = ::std::move(from);
  }

  inline BlockHeaderResponse& operator=(const BlockHeaderResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeaderResponse& operator=(BlockHeaderResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeaderResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeaderResponse* internal_default_instance() {
    return reinterpret_cast<const BlockHeaderResponse*>(
               &_BlockHeaderResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(BlockHeaderResponse& a, BlockHeaderResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeaderResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeaderResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeaderResponse* New() const final {
    return new BlockHeaderResponse();
  }

  BlockHeaderResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeaderResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeaderResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeaderResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeaderResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockHeaderResponse";
  }
  protected:
  explicit BlockHeaderResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .flow.access.BlockHeader block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::flow::access::BlockHeader& block() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::BlockHeader* release_block();
  ::flow::access::BlockHeader* mutable_block();
  void set_allocated_block(::flow::access::BlockHeader* block);
  private:
  const ::flow::access::BlockHeader& _internal_block() const;
  ::flow::access::BlockHeader* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::flow::access::BlockHeader* block);
  ::flow::access::BlockHeader* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:flow.access.BlockHeaderResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::BlockHeader* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetLatestBlockHeaderRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetLatestBlockHeaderRequest) */ {
 public:
  inline GetLatestBlockHeaderRequest() : GetLatestBlockHeaderRequest(nullptr) {}
  ~GetLatestBlockHeaderRequest() override;
  explicit constexpr GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestBlockHeaderRequest(const GetLatestBlockHeaderRequest& from);
  GetLatestBlockHeaderRequest(GetLatestBlockHeaderRequest&& from) noexcept
    : GetLatestBlockHeaderRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestBlockHeaderRequest& operator=(const GetLatestBlockHeaderRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockHeaderRequest& operator=(GetLatestBlockHeaderRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockHeaderRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestBlockHeaderRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestBlockHeaderRequest*>(
               &_GetLatestBlockHeaderRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(GetLatestBlockHeaderRequest& a, GetLatestBlockHeaderRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockHeaderRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestBlockHeaderRequest* New() const final {
    return new GetLatestBlockHeaderRequest();
  }

  GetLatestBlockHeaderRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestBlockHeaderRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockHeaderRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockHeaderRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestBlockHeaderRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestBlockHeaderRequest";
  }
  protected:
  explicit GetLatestBlockHeaderRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSealedFieldNumber = 1,
  };
  // bool is_sealed = 1;
  void clear_is_sealed();
  bool is_sealed() const;
  void set_is_sealed(bool value);
  private:
  bool _internal_is_sealed() const;
  void _internal_set_is_sealed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestBlockHeaderRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_sealed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaderByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockHeaderByIdRequest) */ {
 public:
  inline GetBlockHeaderByIdRequest() : GetBlockHeaderByIdRequest(nullptr) {}
  ~GetBlockHeaderByIdRequest() override;
  explicit constexpr GetBlockHeaderByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaderByIdRequest(const GetBlockHeaderByIdRequest& from);
  GetBlockHeaderByIdRequest(GetBlockHeaderByIdRequest&& from) noexcept
    : GetBlockHeaderByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderByIdRequest& operator=(const GetBlockHeaderByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaderByIdRequest& operator=(GetBlockHeaderByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaderByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaderByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderByIdRequest*>(
               &_GetBlockHeaderByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(GetBlockHeaderByIdRequest& a, GetBlockHeaderByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaderByIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaderByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderByIdRequest* New() const final {
    return new GetBlockHeaderByIdRequest();
  }

  GetBlockHeaderByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaderByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockHeaderByIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderByIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockHeaderByIdRequest";
  }
  protected:
  explicit GetBlockHeaderByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockHeaderByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetBlockHeaderByHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockHeaderByHeightRequest) */ {
 public:
  inline GetBlockHeaderByHeightRequest() : GetBlockHeaderByHeightRequest(nullptr) {}
  ~GetBlockHeaderByHeightRequest() override;
  explicit constexpr GetBlockHeaderByHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockHeaderByHeightRequest(const GetBlockHeaderByHeightRequest& from);
  GetBlockHeaderByHeightRequest(GetBlockHeaderByHeightRequest&& from) noexcept
    : GetBlockHeaderByHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockHeaderByHeightRequest& operator=(const GetBlockHeaderByHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockHeaderByHeightRequest& operator=(GetBlockHeaderByHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockHeaderByHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockHeaderByHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockHeaderByHeightRequest*>(
               &_GetBlockHeaderByHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(GetBlockHeaderByHeightRequest& a, GetBlockHeaderByHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockHeaderByHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockHeaderByHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockHeaderByHeightRequest* New() const final {
    return new GetBlockHeaderByHeightRequest();
  }

  GetBlockHeaderByHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockHeaderByHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockHeaderByHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockHeaderByHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockHeaderByHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockHeaderByHeightRequest";
  }
  protected:
  explicit GetBlockHeaderByHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockHeaderByHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class BlockResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockResponse) */ {
 public:
  inline BlockResponse() : BlockResponse(nullptr) {}
  ~BlockResponse() override;
  explicit constexpr BlockResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockResponse(const BlockResponse& from);
  BlockResponse(BlockResponse&& from) noexcept
    : BlockResponse() {
    *this = ::std::move(from);
  }

  inline BlockResponse& operator=(const BlockResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockResponse& operator=(BlockResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockResponse* internal_default_instance() {
    return reinterpret_cast<const BlockResponse*>(
               &_BlockResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(BlockResponse& a, BlockResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockResponse* New() const final {
    return new BlockResponse();
  }

  BlockResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockResponse";
  }
  protected:
  explicit BlockResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockFieldNumber = 1,
  };
  // .flow.access.Block block = 1;
  bool has_block() const;
  private:
  bool _internal_has_block() const;
  public:
  void clear_block();
  const ::flow::access::Block& block() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Block* release_block();
  ::flow::access::Block* mutable_block();
  void set_allocated_block(::flow::access::Block* block);
  private:
  const ::flow::access::Block& _internal_block() const;
  ::flow::access::Block* _internal_mutable_block();
  public:
  void unsafe_arena_set_allocated_block(
      ::flow::access::Block* block);
  ::flow::access::Block* unsafe_arena_release_block();

  // @@protoc_insertion_point(class_scope:flow.access.BlockResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::Block* block_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetLatestBlockRequest) */ {
 public:
  inline GetLatestBlockRequest() : GetLatestBlockRequest(nullptr) {}
  ~GetLatestBlockRequest() override;
  explicit constexpr GetLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestBlockRequest(const GetLatestBlockRequest& from);
  GetLatestBlockRequest(GetLatestBlockRequest&& from) noexcept
    : GetLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestBlockRequest& operator=(const GetLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestBlockRequest& operator=(GetLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestBlockRequest*>(
               &_GetLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(GetLatestBlockRequest& a, GetLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestBlockRequest* New() const final {
    return new GetLatestBlockRequest();
  }

  GetLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestBlockRequest";
  }
  protected:
  explicit GetLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIsSealedFieldNumber = 1,
  };
  // bool is_sealed = 1;
  void clear_is_sealed();
  bool is_sealed() const;
  void set_is_sealed(bool value);
  private:
  bool _internal_is_sealed() const;
  void _internal_set_is_sealed(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  bool is_sealed_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetBlockByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockByIdRequest) */ {
 public:
  inline GetBlockByIdRequest() : GetBlockByIdRequest(nullptr) {}
  ~GetBlockByIdRequest() override;
  explicit constexpr GetBlockByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockByIdRequest(const GetBlockByIdRequest& from);
  GetBlockByIdRequest(GetBlockByIdRequest&& from) noexcept
    : GetBlockByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByIdRequest& operator=(const GetBlockByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockByIdRequest& operator=(GetBlockByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByIdRequest*>(
               &_GetBlockByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(GetBlockByIdRequest& a, GetBlockByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockByIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByIdRequest* New() const final {
    return new GetBlockByIdRequest();
  }

  GetBlockByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockByIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockByIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockByIdRequest";
  }
  protected:
  explicit GetBlockByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetBlockByHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetBlockByHeightRequest) */ {
 public:
  inline GetBlockByHeightRequest() : GetBlockByHeightRequest(nullptr) {}
  ~GetBlockByHeightRequest() override;
  explicit constexpr GetBlockByHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetBlockByHeightRequest(const GetBlockByHeightRequest& from);
  GetBlockByHeightRequest(GetBlockByHeightRequest&& from) noexcept
    : GetBlockByHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetBlockByHeightRequest& operator=(const GetBlockByHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetBlockByHeightRequest& operator=(GetBlockByHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetBlockByHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetBlockByHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetBlockByHeightRequest*>(
               &_GetBlockByHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(GetBlockByHeightRequest& a, GetBlockByHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetBlockByHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetBlockByHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetBlockByHeightRequest* New() const final {
    return new GetBlockByHeightRequest();
  }

  GetBlockByHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetBlockByHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetBlockByHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetBlockByHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetBlockByHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetBlockByHeightRequest";
  }
  protected:
  explicit GetBlockByHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kHeightFieldNumber = 1,
  };
  // uint64 height = 1;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetBlockByHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class CollectionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.CollectionResponse) */ {
 public:
  inline CollectionResponse() : CollectionResponse(nullptr) {}
  ~CollectionResponse() override;
  explicit constexpr CollectionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectionResponse(const CollectionResponse& from);
  CollectionResponse(CollectionResponse&& from) noexcept
    : CollectionResponse() {
    *this = ::std::move(from);
  }

  inline CollectionResponse& operator=(const CollectionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionResponse& operator=(CollectionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionResponse* internal_default_instance() {
    return reinterpret_cast<const CollectionResponse*>(
               &_CollectionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CollectionResponse& a, CollectionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CollectionResponse* New() const final {
    return new CollectionResponse();
  }

  CollectionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CollectionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollectionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.CollectionResponse";
  }
  protected:
  explicit CollectionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionFieldNumber = 1,
  };
  // .flow.access.Collection collection = 1;
  bool has_collection() const;
  private:
  bool _internal_has_collection() const;
  public:
  void clear_collection();
  const ::flow::access::Collection& collection() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Collection* release_collection();
  ::flow::access::Collection* mutable_collection();
  void set_allocated_collection(::flow::access::Collection* collection);
  private:
  const ::flow::access::Collection& _internal_collection() const;
  ::flow::access::Collection* _internal_mutable_collection();
  public:
  void unsafe_arena_set_allocated_collection(
      ::flow::access::Collection* collection);
  ::flow::access::Collection* unsafe_arena_release_collection();

  // @@protoc_insertion_point(class_scope:flow.access.CollectionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::Collection* collection_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetCollectionByIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetCollectionByIdRequest) */ {
 public:
  inline GetCollectionByIdRequest() : GetCollectionByIdRequest(nullptr) {}
  ~GetCollectionByIdRequest() override;
  explicit constexpr GetCollectionByIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetCollectionByIdRequest(const GetCollectionByIdRequest& from);
  GetCollectionByIdRequest(GetCollectionByIdRequest&& from) noexcept
    : GetCollectionByIdRequest() {
    *this = ::std::move(from);
  }

  inline GetCollectionByIdRequest& operator=(const GetCollectionByIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetCollectionByIdRequest& operator=(GetCollectionByIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetCollectionByIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetCollectionByIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetCollectionByIdRequest*>(
               &_GetCollectionByIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(GetCollectionByIdRequest& a, GetCollectionByIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetCollectionByIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetCollectionByIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetCollectionByIdRequest* New() const final {
    return new GetCollectionByIdRequest();
  }

  GetCollectionByIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetCollectionByIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetCollectionByIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetCollectionByIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetCollectionByIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetCollectionByIdRequest";
  }
  protected:
  explicit GetCollectionByIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetCollectionByIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class SendTransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.SendTransactionResponse) */ {
 public:
  inline SendTransactionResponse() : SendTransactionResponse(nullptr) {}
  ~SendTransactionResponse() override;
  explicit constexpr SendTransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTransactionResponse(const SendTransactionResponse& from);
  SendTransactionResponse(SendTransactionResponse&& from) noexcept
    : SendTransactionResponse() {
    *this = ::std::move(from);
  }

  inline SendTransactionResponse& operator=(const SendTransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTransactionResponse& operator=(SendTransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTransactionResponse* internal_default_instance() {
    return reinterpret_cast<const SendTransactionResponse*>(
               &_SendTransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(SendTransactionResponse& a, SendTransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTransactionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionResponse* New() const final {
    return new SendTransactionResponse();
  }

  SendTransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTransactionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTransactionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.SendTransactionResponse";
  }
  protected:
  explicit SendTransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.SendTransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class SendTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.SendTransactionRequest) */ {
 public:
  inline SendTransactionRequest() : SendTransactionRequest(nullptr) {}
  ~SendTransactionRequest() override;
  explicit constexpr SendTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SendTransactionRequest(const SendTransactionRequest& from);
  SendTransactionRequest(SendTransactionRequest&& from) noexcept
    : SendTransactionRequest() {
    *this = ::std::move(from);
  }

  inline SendTransactionRequest& operator=(const SendTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline SendTransactionRequest& operator=(SendTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SendTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const SendTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const SendTransactionRequest*>(
               &_SendTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(SendTransactionRequest& a, SendTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(SendTransactionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SendTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline SendTransactionRequest* New() const final {
    return new SendTransactionRequest();
  }

  SendTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<SendTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SendTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const SendTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SendTransactionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.SendTransactionRequest";
  }
  protected:
  explicit SendTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .flow.access.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::flow::access::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Transaction* release_transaction();
  ::flow::access::Transaction* mutable_transaction();
  void set_allocated_transaction(::flow::access::Transaction* transaction);
  private:
  const ::flow::access::Transaction& _internal_transaction() const;
  ::flow::access::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::flow::access::Transaction* transaction);
  ::flow::access::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:flow.access.SendTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetTransactionRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetTransactionRequest) */ {
 public:
  inline GetTransactionRequest() : GetTransactionRequest(nullptr) {}
  ~GetTransactionRequest() override;
  explicit constexpr GetTransactionRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetTransactionRequest(const GetTransactionRequest& from);
  GetTransactionRequest(GetTransactionRequest&& from) noexcept
    : GetTransactionRequest() {
    *this = ::std::move(from);
  }

  inline GetTransactionRequest& operator=(const GetTransactionRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetTransactionRequest& operator=(GetTransactionRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetTransactionRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetTransactionRequest* internal_default_instance() {
    return reinterpret_cast<const GetTransactionRequest*>(
               &_GetTransactionRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  friend void swap(GetTransactionRequest& a, GetTransactionRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetTransactionRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetTransactionRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetTransactionRequest* New() const final {
    return new GetTransactionRequest();
  }

  GetTransactionRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetTransactionRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetTransactionRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetTransactionRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetTransactionRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetTransactionRequest";
  }
  protected:
  explicit GetTransactionRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetTransactionRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class TransactionResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionResponse) */ {
 public:
  inline TransactionResponse() : TransactionResponse(nullptr) {}
  ~TransactionResponse() override;
  explicit constexpr TransactionResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionResponse(const TransactionResponse& from);
  TransactionResponse(TransactionResponse&& from) noexcept
    : TransactionResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResponse& operator=(const TransactionResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionResponse& operator=(TransactionResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResponse*>(
               &_TransactionResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  friend void swap(TransactionResponse& a, TransactionResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionResponse* New() const final {
    return new TransactionResponse();
  }

  TransactionResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionResponse";
  }
  protected:
  explicit TransactionResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionFieldNumber = 1,
  };
  // .flow.access.Transaction transaction = 1;
  bool has_transaction() const;
  private:
  bool _internal_has_transaction() const;
  public:
  void clear_transaction();
  const ::flow::access::Transaction& transaction() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Transaction* release_transaction();
  ::flow::access::Transaction* mutable_transaction();
  void set_allocated_transaction(::flow::access::Transaction* transaction);
  private:
  const ::flow::access::Transaction& _internal_transaction() const;
  ::flow::access::Transaction* _internal_mutable_transaction();
  public:
  void unsafe_arena_set_allocated_transaction(
      ::flow::access::Transaction* transaction);
  ::flow::access::Transaction* unsafe_arena_release_transaction();

  // @@protoc_insertion_point(class_scope:flow.access.TransactionResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::Transaction* transaction_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class TransactionResultResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionResultResponse) */ {
 public:
  inline TransactionResultResponse() : TransactionResultResponse(nullptr) {}
  ~TransactionResultResponse() override;
  explicit constexpr TransactionResultResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionResultResponse(const TransactionResultResponse& from);
  TransactionResultResponse(TransactionResultResponse&& from) noexcept
    : TransactionResultResponse() {
    *this = ::std::move(from);
  }

  inline TransactionResultResponse& operator=(const TransactionResultResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionResultResponse& operator=(TransactionResultResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionResultResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionResultResponse* internal_default_instance() {
    return reinterpret_cast<const TransactionResultResponse*>(
               &_TransactionResultResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  friend void swap(TransactionResultResponse& a, TransactionResultResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionResultResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionResultResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionResultResponse* New() const final {
    return new TransactionResultResponse();
  }

  TransactionResultResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionResultResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionResultResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionResultResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionResultResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionResultResponse";
  }
  protected:
  explicit TransactionResultResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 4,
    kErrorMessageFieldNumber = 3,
    kStatusFieldNumber = 1,
    kStatusCodeFieldNumber = 2,
  };
  // repeated .flow.access.Event events = 4;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::access::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >*
      mutable_events();
  private:
  const ::flow::access::Event& _internal_events(int index) const;
  ::flow::access::Event* _internal_add_events();
  public:
  const ::flow::access::Event& events(int index) const;
  ::flow::access::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >&
      events() const;

  // string error_message = 3;
  void clear_error_message();
  const std::string& error_message() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_error_message(ArgT0&& arg0, ArgT... args);
  std::string* mutable_error_message();
  PROTOBUF_MUST_USE_RESULT std::string* release_error_message();
  void set_allocated_error_message(std::string* error_message);
  private:
  const std::string& _internal_error_message() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_error_message(const std::string& value);
  std::string* _internal_mutable_error_message();
  public:

  // .flow.access.TransactionStatus status = 1;
  void clear_status();
  ::flow::access::TransactionStatus status() const;
  void set_status(::flow::access::TransactionStatus value);
  private:
  ::flow::access::TransactionStatus _internal_status() const;
  void _internal_set_status(::flow::access::TransactionStatus value);
  public:

  // uint32 status_code = 2;
  void clear_status_code();
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code() const;
  void set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_status_code() const;
  void _internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.TransactionResultResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr error_message_;
  int status_;
  ::PROTOBUF_NAMESPACE_ID::uint32 status_code_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class AccountResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.AccountResponse) */ {
 public:
  inline AccountResponse() : AccountResponse(nullptr) {}
  ~AccountResponse() override;
  explicit constexpr AccountResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountResponse(const AccountResponse& from);
  AccountResponse(AccountResponse&& from) noexcept
    : AccountResponse() {
    *this = ::std::move(from);
  }

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountResponse& operator=(AccountResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountResponse* internal_default_instance() {
    return reinterpret_cast<const AccountResponse*>(
               &_AccountResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  friend void swap(AccountResponse& a, AccountResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountResponse* New() const final {
    return new AccountResponse();
  }

  AccountResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.AccountResponse";
  }
  protected:
  explicit AccountResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccountFieldNumber = 1,
  };
  // .flow.access.Account account = 1;
  bool has_account() const;
  private:
  bool _internal_has_account() const;
  public:
  void clear_account();
  const ::flow::access::Account& account() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Account* release_account();
  ::flow::access::Account* mutable_account();
  void set_allocated_account(::flow::access::Account* account);
  private:
  const ::flow::access::Account& _internal_account() const;
  ::flow::access::Account* _internal_mutable_account();
  public:
  void unsafe_arena_set_allocated_account(
      ::flow::access::Account* account);
  ::flow::access::Account* unsafe_arena_release_account();

  // @@protoc_insertion_point(class_scope:flow.access.AccountResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::Account* account_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountAtLatestBlockRequest) */ {
 public:
  inline GetAccountAtLatestBlockRequest() : GetAccountAtLatestBlockRequest(nullptr) {}
  ~GetAccountAtLatestBlockRequest() override;
  explicit constexpr GetAccountAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtLatestBlockRequest(const GetAccountAtLatestBlockRequest& from);
  GetAccountAtLatestBlockRequest(GetAccountAtLatestBlockRequest&& from) noexcept
    : GetAccountAtLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAtLatestBlockRequest& operator=(const GetAccountAtLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtLatestBlockRequest& operator=(GetAccountAtLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtLatestBlockRequest*>(
               &_GetAccountAtLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  friend void swap(GetAccountAtLatestBlockRequest& a, GetAccountAtLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtLatestBlockRequest* New() const final {
    return new GetAccountAtLatestBlockRequest();
  }

  GetAccountAtLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountAtLatestBlockRequest";
  }
  protected:
  explicit GetAccountAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountAtLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetAccountAtBlockHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetAccountAtBlockHeightRequest) */ {
 public:
  inline GetAccountAtBlockHeightRequest() : GetAccountAtBlockHeightRequest(nullptr) {}
  ~GetAccountAtBlockHeightRequest() override;
  explicit constexpr GetAccountAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetAccountAtBlockHeightRequest(const GetAccountAtBlockHeightRequest& from);
  GetAccountAtBlockHeightRequest(GetAccountAtBlockHeightRequest&& from) noexcept
    : GetAccountAtBlockHeightRequest() {
    *this = ::std::move(from);
  }

  inline GetAccountAtBlockHeightRequest& operator=(const GetAccountAtBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetAccountAtBlockHeightRequest& operator=(GetAccountAtBlockHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetAccountAtBlockHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetAccountAtBlockHeightRequest* internal_default_instance() {
    return reinterpret_cast<const GetAccountAtBlockHeightRequest*>(
               &_GetAccountAtBlockHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  friend void swap(GetAccountAtBlockHeightRequest& a, GetAccountAtBlockHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetAccountAtBlockHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetAccountAtBlockHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetAccountAtBlockHeightRequest* New() const final {
    return new GetAccountAtBlockHeightRequest();
  }

  GetAccountAtBlockHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetAccountAtBlockHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetAccountAtBlockHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetAccountAtBlockHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetAccountAtBlockHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetAccountAtBlockHeightRequest";
  }
  protected:
  explicit GetAccountAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kBlockHeightFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetAccountAtBlockHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptResponse) */ {
 public:
  inline ExecuteScriptResponse() : ExecuteScriptResponse(nullptr) {}
  ~ExecuteScriptResponse() override;
  explicit constexpr ExecuteScriptResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptResponse(const ExecuteScriptResponse& from);
  ExecuteScriptResponse(ExecuteScriptResponse&& from) noexcept
    : ExecuteScriptResponse() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptResponse& operator=(const ExecuteScriptResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptResponse& operator=(ExecuteScriptResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptResponse* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptResponse*>(
               &_ExecuteScriptResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  friend void swap(ExecuteScriptResponse& a, ExecuteScriptResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptResponse* New() const final {
    return new ExecuteScriptResponse();
  }

  ExecuteScriptResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptResponse";
  }
  protected:
  explicit ExecuteScriptResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kValueFieldNumber = 1,
  };
  // bytes value = 1;
  void clear_value();
  const std::string& value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_value();
  PROTOBUF_MUST_USE_RESULT std::string* release_value();
  void set_allocated_value(std::string* value);
  private:
  const std::string& _internal_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_value(const std::string& value);
  std::string* _internal_mutable_value();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr value_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtLatestBlockRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtLatestBlockRequest) */ {
 public:
  inline ExecuteScriptAtLatestBlockRequest() : ExecuteScriptAtLatestBlockRequest(nullptr) {}
  ~ExecuteScriptAtLatestBlockRequest() override;
  explicit constexpr ExecuteScriptAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtLatestBlockRequest(const ExecuteScriptAtLatestBlockRequest& from);
  ExecuteScriptAtLatestBlockRequest(ExecuteScriptAtLatestBlockRequest&& from) noexcept
    : ExecuteScriptAtLatestBlockRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtLatestBlockRequest& operator=(const ExecuteScriptAtLatestBlockRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtLatestBlockRequest& operator=(ExecuteScriptAtLatestBlockRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtLatestBlockRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtLatestBlockRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtLatestBlockRequest*>(
               &_ExecuteScriptAtLatestBlockRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  friend void swap(ExecuteScriptAtLatestBlockRequest& a, ExecuteScriptAtLatestBlockRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtLatestBlockRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtLatestBlockRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtLatestBlockRequest* New() const final {
    return new ExecuteScriptAtLatestBlockRequest();
  }

  ExecuteScriptAtLatestBlockRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtLatestBlockRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtLatestBlockRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtLatestBlockRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtLatestBlockRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtLatestBlockRequest";
  }
  protected:
  explicit ExecuteScriptAtLatestBlockRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 1,
  };
  // bytes script = 1;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtLatestBlockRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtBlockIdRequest) */ {
 public:
  inline ExecuteScriptAtBlockIdRequest() : ExecuteScriptAtBlockIdRequest(nullptr) {}
  ~ExecuteScriptAtBlockIdRequest() override;
  explicit constexpr ExecuteScriptAtBlockIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockIdRequest(const ExecuteScriptAtBlockIdRequest& from);
  ExecuteScriptAtBlockIdRequest(ExecuteScriptAtBlockIdRequest&& from) noexcept
    : ExecuteScriptAtBlockIdRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockIdRequest& operator=(const ExecuteScriptAtBlockIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockIdRequest& operator=(ExecuteScriptAtBlockIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockIdRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockIdRequest*>(
               &_ExecuteScriptAtBlockIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  friend void swap(ExecuteScriptAtBlockIdRequest& a, ExecuteScriptAtBlockIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockIdRequest* New() const final {
    return new ExecuteScriptAtBlockIdRequest();
  }

  ExecuteScriptAtBlockIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtBlockIdRequest";
  }
  protected:
  explicit ExecuteScriptAtBlockIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
    kScriptFieldNumber = 2,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtBlockIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecuteScriptAtBlockHeightRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecuteScriptAtBlockHeightRequest) */ {
 public:
  inline ExecuteScriptAtBlockHeightRequest() : ExecuteScriptAtBlockHeightRequest(nullptr) {}
  ~ExecuteScriptAtBlockHeightRequest() override;
  explicit constexpr ExecuteScriptAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecuteScriptAtBlockHeightRequest(const ExecuteScriptAtBlockHeightRequest& from);
  ExecuteScriptAtBlockHeightRequest(ExecuteScriptAtBlockHeightRequest&& from) noexcept
    : ExecuteScriptAtBlockHeightRequest() {
    *this = ::std::move(from);
  }

  inline ExecuteScriptAtBlockHeightRequest& operator=(const ExecuteScriptAtBlockHeightRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecuteScriptAtBlockHeightRequest& operator=(ExecuteScriptAtBlockHeightRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecuteScriptAtBlockHeightRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecuteScriptAtBlockHeightRequest* internal_default_instance() {
    return reinterpret_cast<const ExecuteScriptAtBlockHeightRequest*>(
               &_ExecuteScriptAtBlockHeightRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  friend void swap(ExecuteScriptAtBlockHeightRequest& a, ExecuteScriptAtBlockHeightRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecuteScriptAtBlockHeightRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecuteScriptAtBlockHeightRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecuteScriptAtBlockHeightRequest* New() const final {
    return new ExecuteScriptAtBlockHeightRequest();
  }

  ExecuteScriptAtBlockHeightRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecuteScriptAtBlockHeightRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecuteScriptAtBlockHeightRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecuteScriptAtBlockHeightRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecuteScriptAtBlockHeightRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecuteScriptAtBlockHeightRequest";
  }
  protected:
  explicit ExecuteScriptAtBlockHeightRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kScriptFieldNumber = 2,
    kBlockHeightFieldNumber = 1,
  };
  // bytes script = 2;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // uint64 block_height = 1;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecuteScriptAtBlockHeightRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse_Result final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.EventsResponse.Result) */ {
 public:
  inline EventsResponse_Result() : EventsResponse_Result(nullptr) {}
  ~EventsResponse_Result() override;
  explicit constexpr EventsResponse_Result(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResponse_Result(const EventsResponse_Result& from);
  EventsResponse_Result(EventsResponse_Result&& from) noexcept
    : EventsResponse_Result() {
    *this = ::std::move(from);
  }

  inline EventsResponse_Result& operator=(const EventsResponse_Result& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse_Result& operator=(EventsResponse_Result&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse_Result& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse_Result* internal_default_instance() {
    return reinterpret_cast<const EventsResponse_Result*>(
               &_EventsResponse_Result_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  friend void swap(EventsResponse_Result& a, EventsResponse_Result& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResponse_Result* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse_Result* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EventsResponse_Result* New() const final {
    return new EventsResponse_Result();
  }

  EventsResponse_Result* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EventsResponse_Result>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResponse_Result& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventsResponse_Result& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResponse_Result* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.EventsResponse.Result";
  }
  protected:
  explicit EventsResponse_Result(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEventsFieldNumber = 3,
    kBlockIdFieldNumber = 1,
    kBlockTimestampFieldNumber = 4,
    kBlockHeightFieldNumber = 2,
  };
  // repeated .flow.access.Event events = 3;
  int events_size() const;
  private:
  int _internal_events_size() const;
  public:
  void clear_events();
  ::flow::access::Event* mutable_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >*
      mutable_events();
  private:
  const ::flow::access::Event& _internal_events(int index) const;
  ::flow::access::Event* _internal_add_events();
  public:
  const ::flow::access::Event& events(int index) const;
  ::flow::access::Event* add_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >&
      events() const;

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // .flow.access.Timestamp block_timestamp = 4;
  bool has_block_timestamp() const;
  private:
  bool _internal_has_block_timestamp() const;
  public:
  void clear_block_timestamp();
  const ::flow::access::Timestamp& block_timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Timestamp* release_block_timestamp();
  ::flow::access::Timestamp* mutable_block_timestamp();
  void set_allocated_block_timestamp(::flow::access::Timestamp* block_timestamp);
  private:
  const ::flow::access::Timestamp& _internal_block_timestamp() const;
  ::flow::access::Timestamp* _internal_mutable_block_timestamp();
  public:
  void unsafe_arena_set_allocated_block_timestamp(
      ::flow::access::Timestamp* block_timestamp);
  ::flow::access::Timestamp* unsafe_arena_release_block_timestamp();

  // uint64 block_height = 2;
  void clear_block_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height() const;
  void set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_block_height() const;
  void _internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.EventsResponse.Result)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event > events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::flow::access::Timestamp* block_timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 block_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class EventsResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.EventsResponse) */ {
 public:
  inline EventsResponse() : EventsResponse(nullptr) {}
  ~EventsResponse() override;
  explicit constexpr EventsResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  EventsResponse(const EventsResponse& from);
  EventsResponse(EventsResponse&& from) noexcept
    : EventsResponse() {
    *this = ::std::move(from);
  }

  inline EventsResponse& operator=(const EventsResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline EventsResponse& operator=(EventsResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const EventsResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const EventsResponse* internal_default_instance() {
    return reinterpret_cast<const EventsResponse*>(
               &_EventsResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  friend void swap(EventsResponse& a, EventsResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(EventsResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(EventsResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline EventsResponse* New() const final {
    return new EventsResponse();
  }

  EventsResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<EventsResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const EventsResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const EventsResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(EventsResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.EventsResponse";
  }
  protected:
  explicit EventsResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef EventsResponse_Result Result;

  // accessors -------------------------------------------------------

  enum : int {
    kResultsFieldNumber = 1,
  };
  // repeated .flow.access.EventsResponse.Result results = 1;
  int results_size() const;
  private:
  int _internal_results_size() const;
  public:
  void clear_results();
  ::flow::access::EventsResponse_Result* mutable_results(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >*
      mutable_results();
  private:
  const ::flow::access::EventsResponse_Result& _internal_results(int index) const;
  ::flow::access::EventsResponse_Result* _internal_add_results();
  public:
  const ::flow::access::EventsResponse_Result& results(int index) const;
  ::flow::access::EventsResponse_Result* add_results();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >&
      results() const;

  // @@protoc_insertion_point(class_scope:flow.access.EventsResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result > results_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForHeightRangeRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetEventsForHeightRangeRequest) */ {
 public:
  inline GetEventsForHeightRangeRequest() : GetEventsForHeightRangeRequest(nullptr) {}
  ~GetEventsForHeightRangeRequest() override;
  explicit constexpr GetEventsForHeightRangeRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForHeightRangeRequest(const GetEventsForHeightRangeRequest& from);
  GetEventsForHeightRangeRequest(GetEventsForHeightRangeRequest&& from) noexcept
    : GetEventsForHeightRangeRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsForHeightRangeRequest& operator=(const GetEventsForHeightRangeRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForHeightRangeRequest& operator=(GetEventsForHeightRangeRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForHeightRangeRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForHeightRangeRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsForHeightRangeRequest*>(
               &_GetEventsForHeightRangeRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  friend void swap(GetEventsForHeightRangeRequest& a, GetEventsForHeightRangeRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForHeightRangeRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForHeightRangeRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForHeightRangeRequest* New() const final {
    return new GetEventsForHeightRangeRequest();
  }

  GetEventsForHeightRangeRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForHeightRangeRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForHeightRangeRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForHeightRangeRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForHeightRangeRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetEventsForHeightRangeRequest";
  }
  protected:
  explicit GetEventsForHeightRangeRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kStartHeightFieldNumber = 2,
    kEndHeightFieldNumber = 3,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // uint64 start_height = 2;
  void clear_start_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 start_height() const;
  void set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_start_height() const;
  void _internal_set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 end_height = 3;
  void clear_end_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 end_height() const;
  void set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_end_height() const;
  void _internal_set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetEventsForHeightRangeRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::uint64 start_height_;
  ::PROTOBUF_NAMESPACE_ID::uint64 end_height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetEventsForBlockIdsRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetEventsForBlockIdsRequest) */ {
 public:
  inline GetEventsForBlockIdsRequest() : GetEventsForBlockIdsRequest(nullptr) {}
  ~GetEventsForBlockIdsRequest() override;
  explicit constexpr GetEventsForBlockIdsRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetEventsForBlockIdsRequest(const GetEventsForBlockIdsRequest& from);
  GetEventsForBlockIdsRequest(GetEventsForBlockIdsRequest&& from) noexcept
    : GetEventsForBlockIdsRequest() {
    *this = ::std::move(from);
  }

  inline GetEventsForBlockIdsRequest& operator=(const GetEventsForBlockIdsRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetEventsForBlockIdsRequest& operator=(GetEventsForBlockIdsRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetEventsForBlockIdsRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetEventsForBlockIdsRequest* internal_default_instance() {
    return reinterpret_cast<const GetEventsForBlockIdsRequest*>(
               &_GetEventsForBlockIdsRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  friend void swap(GetEventsForBlockIdsRequest& a, GetEventsForBlockIdsRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetEventsForBlockIdsRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetEventsForBlockIdsRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetEventsForBlockIdsRequest* New() const final {
    return new GetEventsForBlockIdsRequest();
  }

  GetEventsForBlockIdsRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetEventsForBlockIdsRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetEventsForBlockIdsRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetEventsForBlockIdsRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetEventsForBlockIdsRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetEventsForBlockIdsRequest";
  }
  protected:
  explicit GetEventsForBlockIdsRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdsFieldNumber = 2,
    kTypeFieldNumber = 1,
  };
  // repeated bytes block_ids = 2;
  int block_ids_size() const;
  private:
  int _internal_block_ids_size() const;
  public:
  void clear_block_ids();
  const std::string& block_ids(int index) const;
  std::string* mutable_block_ids(int index);
  void set_block_ids(int index, const std::string& value);
  void set_block_ids(int index, std::string&& value);
  void set_block_ids(int index, const char* value);
  void set_block_ids(int index, const void* value, size_t size);
  std::string* add_block_ids();
  void add_block_ids(const std::string& value);
  void add_block_ids(std::string&& value);
  void add_block_ids(const char* value);
  void add_block_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& block_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_block_ids();
  private:
  const std::string& _internal_block_ids(int index) const;
  std::string* _internal_add_block_ids();
  public:

  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetEventsForBlockIdsRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> block_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkParametersResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetNetworkParametersResponse) */ {
 public:
  inline GetNetworkParametersResponse() : GetNetworkParametersResponse(nullptr) {}
  ~GetNetworkParametersResponse() override;
  explicit constexpr GetNetworkParametersResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkParametersResponse(const GetNetworkParametersResponse& from);
  GetNetworkParametersResponse(GetNetworkParametersResponse&& from) noexcept
    : GetNetworkParametersResponse() {
    *this = ::std::move(from);
  }

  inline GetNetworkParametersResponse& operator=(const GetNetworkParametersResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkParametersResponse& operator=(GetNetworkParametersResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkParametersResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkParametersResponse* internal_default_instance() {
    return reinterpret_cast<const GetNetworkParametersResponse*>(
               &_GetNetworkParametersResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  friend void swap(GetNetworkParametersResponse& a, GetNetworkParametersResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkParametersResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkParametersResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkParametersResponse* New() const final {
    return new GetNetworkParametersResponse();
  }

  GetNetworkParametersResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkParametersResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNetworkParametersResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNetworkParametersResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkParametersResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetNetworkParametersResponse";
  }
  protected:
  explicit GetNetworkParametersResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChainIdFieldNumber = 1,
  };
  // string chain_id = 1;
  void clear_chain_id();
  const std::string& chain_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_chain_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_chain_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_chain_id();
  void set_allocated_chain_id(std::string* chain_id);
  private:
  const std::string& _internal_chain_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_chain_id(const std::string& value);
  std::string* _internal_mutable_chain_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetNetworkParametersResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr chain_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetNetworkParametersRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetNetworkParametersRequest) */ {
 public:
  inline GetNetworkParametersRequest() : GetNetworkParametersRequest(nullptr) {}
  ~GetNetworkParametersRequest() override;
  explicit constexpr GetNetworkParametersRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetNetworkParametersRequest(const GetNetworkParametersRequest& from);
  GetNetworkParametersRequest(GetNetworkParametersRequest&& from) noexcept
    : GetNetworkParametersRequest() {
    *this = ::std::move(from);
  }

  inline GetNetworkParametersRequest& operator=(const GetNetworkParametersRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetNetworkParametersRequest& operator=(GetNetworkParametersRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetNetworkParametersRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetNetworkParametersRequest* internal_default_instance() {
    return reinterpret_cast<const GetNetworkParametersRequest*>(
               &_GetNetworkParametersRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    29;

  friend void swap(GetNetworkParametersRequest& a, GetNetworkParametersRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetNetworkParametersRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetNetworkParametersRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetNetworkParametersRequest* New() const final {
    return new GetNetworkParametersRequest();
  }

  GetNetworkParametersRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetNetworkParametersRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetNetworkParametersRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetNetworkParametersRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetNetworkParametersRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetNetworkParametersRequest";
  }
  protected:
  explicit GetNetworkParametersRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.GetNetworkParametersRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ProtocolStateSnapshotResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ProtocolStateSnapshotResponse) */ {
 public:
  inline ProtocolStateSnapshotResponse() : ProtocolStateSnapshotResponse(nullptr) {}
  ~ProtocolStateSnapshotResponse() override;
  explicit constexpr ProtocolStateSnapshotResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ProtocolStateSnapshotResponse(const ProtocolStateSnapshotResponse& from);
  ProtocolStateSnapshotResponse(ProtocolStateSnapshotResponse&& from) noexcept
    : ProtocolStateSnapshotResponse() {
    *this = ::std::move(from);
  }

  inline ProtocolStateSnapshotResponse& operator=(const ProtocolStateSnapshotResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ProtocolStateSnapshotResponse& operator=(ProtocolStateSnapshotResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ProtocolStateSnapshotResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ProtocolStateSnapshotResponse* internal_default_instance() {
    return reinterpret_cast<const ProtocolStateSnapshotResponse*>(
               &_ProtocolStateSnapshotResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    30;

  friend void swap(ProtocolStateSnapshotResponse& a, ProtocolStateSnapshotResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ProtocolStateSnapshotResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ProtocolStateSnapshotResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ProtocolStateSnapshotResponse* New() const final {
    return new ProtocolStateSnapshotResponse();
  }

  ProtocolStateSnapshotResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ProtocolStateSnapshotResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ProtocolStateSnapshotResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ProtocolStateSnapshotResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ProtocolStateSnapshotResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ProtocolStateSnapshotResponse";
  }
  protected:
  explicit ProtocolStateSnapshotResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSerializedSnapshotFieldNumber = 1,
  };
  // bytes serializedSnapshot = 1;
  void clear_serializedsnapshot();
  const std::string& serializedsnapshot() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_serializedsnapshot(ArgT0&& arg0, ArgT... args);
  std::string* mutable_serializedsnapshot();
  PROTOBUF_MUST_USE_RESULT std::string* release_serializedsnapshot();
  void set_allocated_serializedsnapshot(std::string* serializedsnapshot);
  private:
  const std::string& _internal_serializedsnapshot() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_serializedsnapshot(const std::string& value);
  std::string* _internal_mutable_serializedsnapshot();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ProtocolStateSnapshotResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr serializedsnapshot_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetLatestProtocolStateSnapshotRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetLatestProtocolStateSnapshotRequest) */ {
 public:
  inline GetLatestProtocolStateSnapshotRequest() : GetLatestProtocolStateSnapshotRequest(nullptr) {}
  ~GetLatestProtocolStateSnapshotRequest() override;
  explicit constexpr GetLatestProtocolStateSnapshotRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetLatestProtocolStateSnapshotRequest(const GetLatestProtocolStateSnapshotRequest& from);
  GetLatestProtocolStateSnapshotRequest(GetLatestProtocolStateSnapshotRequest&& from) noexcept
    : GetLatestProtocolStateSnapshotRequest() {
    *this = ::std::move(from);
  }

  inline GetLatestProtocolStateSnapshotRequest& operator=(const GetLatestProtocolStateSnapshotRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetLatestProtocolStateSnapshotRequest& operator=(GetLatestProtocolStateSnapshotRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetLatestProtocolStateSnapshotRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetLatestProtocolStateSnapshotRequest* internal_default_instance() {
    return reinterpret_cast<const GetLatestProtocolStateSnapshotRequest*>(
               &_GetLatestProtocolStateSnapshotRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    31;

  friend void swap(GetLatestProtocolStateSnapshotRequest& a, GetLatestProtocolStateSnapshotRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetLatestProtocolStateSnapshotRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetLatestProtocolStateSnapshotRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetLatestProtocolStateSnapshotRequest* New() const final {
    return new GetLatestProtocolStateSnapshotRequest();
  }

  GetLatestProtocolStateSnapshotRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetLatestProtocolStateSnapshotRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetLatestProtocolStateSnapshotRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetLatestProtocolStateSnapshotRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetLatestProtocolStateSnapshotRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetLatestProtocolStateSnapshotRequest";
  }
  protected:
  explicit GetLatestProtocolStateSnapshotRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:flow.access.GetLatestProtocolStateSnapshotRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecutionResultForBlockIdResponse final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecutionResultForBlockIdResponse) */ {
 public:
  inline ExecutionResultForBlockIdResponse() : ExecutionResultForBlockIdResponse(nullptr) {}
  ~ExecutionResultForBlockIdResponse() override;
  explicit constexpr ExecutionResultForBlockIdResponse(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionResultForBlockIdResponse(const ExecutionResultForBlockIdResponse& from);
  ExecutionResultForBlockIdResponse(ExecutionResultForBlockIdResponse&& from) noexcept
    : ExecutionResultForBlockIdResponse() {
    *this = ::std::move(from);
  }

  inline ExecutionResultForBlockIdResponse& operator=(const ExecutionResultForBlockIdResponse& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionResultForBlockIdResponse& operator=(ExecutionResultForBlockIdResponse&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionResultForBlockIdResponse& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionResultForBlockIdResponse* internal_default_instance() {
    return reinterpret_cast<const ExecutionResultForBlockIdResponse*>(
               &_ExecutionResultForBlockIdResponse_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    32;

  friend void swap(ExecutionResultForBlockIdResponse& a, ExecutionResultForBlockIdResponse& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionResultForBlockIdResponse* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionResultForBlockIdResponse* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecutionResultForBlockIdResponse* New() const final {
    return new ExecutionResultForBlockIdResponse();
  }

  ExecutionResultForBlockIdResponse* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionResultForBlockIdResponse>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionResultForBlockIdResponse& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecutionResultForBlockIdResponse& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionResultForBlockIdResponse* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecutionResultForBlockIdResponse";
  }
  protected:
  explicit ExecutionResultForBlockIdResponse(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionResultFieldNumber = 1,
  };
  // .flow.access.ExecutionResult execution_result = 1;
  bool has_execution_result() const;
  private:
  bool _internal_has_execution_result() const;
  public:
  void clear_execution_result();
  const ::flow::access::ExecutionResult& execution_result() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::ExecutionResult* release_execution_result();
  ::flow::access::ExecutionResult* mutable_execution_result();
  void set_allocated_execution_result(::flow::access::ExecutionResult* execution_result);
  private:
  const ::flow::access::ExecutionResult& _internal_execution_result() const;
  ::flow::access::ExecutionResult* _internal_mutable_execution_result();
  public:
  void unsafe_arena_set_allocated_execution_result(
      ::flow::access::ExecutionResult* execution_result);
  ::flow::access::ExecutionResult* unsafe_arena_release_execution_result();

  // @@protoc_insertion_point(class_scope:flow.access.ExecutionResultForBlockIdResponse)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::flow::access::ExecutionResult* execution_result_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class GetExecutionResultForBlockIdRequest final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.GetExecutionResultForBlockIdRequest) */ {
 public:
  inline GetExecutionResultForBlockIdRequest() : GetExecutionResultForBlockIdRequest(nullptr) {}
  ~GetExecutionResultForBlockIdRequest() override;
  explicit constexpr GetExecutionResultForBlockIdRequest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  GetExecutionResultForBlockIdRequest(const GetExecutionResultForBlockIdRequest& from);
  GetExecutionResultForBlockIdRequest(GetExecutionResultForBlockIdRequest&& from) noexcept
    : GetExecutionResultForBlockIdRequest() {
    *this = ::std::move(from);
  }

  inline GetExecutionResultForBlockIdRequest& operator=(const GetExecutionResultForBlockIdRequest& from) {
    CopyFrom(from);
    return *this;
  }
  inline GetExecutionResultForBlockIdRequest& operator=(GetExecutionResultForBlockIdRequest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const GetExecutionResultForBlockIdRequest& default_instance() {
    return *internal_default_instance();
  }
  static inline const GetExecutionResultForBlockIdRequest* internal_default_instance() {
    return reinterpret_cast<const GetExecutionResultForBlockIdRequest*>(
               &_GetExecutionResultForBlockIdRequest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    33;

  friend void swap(GetExecutionResultForBlockIdRequest& a, GetExecutionResultForBlockIdRequest& b) {
    a.Swap(&b);
  }
  inline void Swap(GetExecutionResultForBlockIdRequest* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(GetExecutionResultForBlockIdRequest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline GetExecutionResultForBlockIdRequest* New() const final {
    return new GetExecutionResultForBlockIdRequest();
  }

  GetExecutionResultForBlockIdRequest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<GetExecutionResultForBlockIdRequest>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const GetExecutionResultForBlockIdRequest& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const GetExecutionResultForBlockIdRequest& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GetExecutionResultForBlockIdRequest* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.GetExecutionResultForBlockIdRequest";
  }
  protected:
  explicit GetExecutionResultForBlockIdRequest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kBlockIdFieldNumber = 1,
  };
  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.GetExecutionResultForBlockIdRequest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Block final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Block) */ {
 public:
  inline Block() : Block(nullptr) {}
  ~Block() override;
  explicit constexpr Block(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Block(const Block& from);
  Block(Block&& from) noexcept
    : Block() {
    *this = ::std::move(from);
  }

  inline Block& operator=(const Block& from) {
    CopyFrom(from);
    return *this;
  }
  inline Block& operator=(Block&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Block& default_instance() {
    return *internal_default_instance();
  }
  static inline const Block* internal_default_instance() {
    return reinterpret_cast<const Block*>(
               &_Block_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    34;

  friend void swap(Block& a, Block& b) {
    a.Swap(&b);
  }
  inline void Swap(Block* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Block* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Block* New() const final {
    return new Block();
  }

  Block* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Block>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Block& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Block& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Block* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Block";
  }
  protected:
  explicit Block(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kCollectionGuaranteesFieldNumber = 5,
    kBlockSealsFieldNumber = 6,
    kSignaturesFieldNumber = 7,
    kIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kTimestampFieldNumber = 4,
    kHeightFieldNumber = 3,
  };
  // repeated .flow.access.CollectionGuarantee collection_guarantees = 5;
  int collection_guarantees_size() const;
  private:
  int _internal_collection_guarantees_size() const;
  public:
  void clear_collection_guarantees();
  ::flow::access::CollectionGuarantee* mutable_collection_guarantees(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::CollectionGuarantee >*
      mutable_collection_guarantees();
  private:
  const ::flow::access::CollectionGuarantee& _internal_collection_guarantees(int index) const;
  ::flow::access::CollectionGuarantee* _internal_add_collection_guarantees();
  public:
  const ::flow::access::CollectionGuarantee& collection_guarantees(int index) const;
  ::flow::access::CollectionGuarantee* add_collection_guarantees();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::CollectionGuarantee >&
      collection_guarantees() const;

  // repeated .flow.access.BlockSeal block_seals = 6;
  int block_seals_size() const;
  private:
  int _internal_block_seals_size() const;
  public:
  void clear_block_seals();
  ::flow::access::BlockSeal* mutable_block_seals(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::BlockSeal >*
      mutable_block_seals();
  private:
  const ::flow::access::BlockSeal& _internal_block_seals(int index) const;
  ::flow::access::BlockSeal* _internal_add_block_seals();
  public:
  const ::flow::access::BlockSeal& block_seals(int index) const;
  ::flow::access::BlockSeal* add_block_seals();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::BlockSeal >&
      block_seals() const;

  // repeated bytes signatures = 7;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  const std::string& signatures(int index) const;
  std::string* mutable_signatures(int index);
  void set_signatures(int index, const std::string& value);
  void set_signatures(int index, std::string&& value);
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  std::string* add_signatures();
  void add_signatures(const std::string& value);
  void add_signatures(std::string&& value);
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signatures();
  private:
  const std::string& _internal_signatures(int index) const;
  std::string* _internal_add_signatures();
  public:

  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes parent_id = 2;
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // .flow.access.Timestamp timestamp = 4;
  bool has_timestamp() const;
  private:
  bool _internal_has_timestamp() const;
  public:
  void clear_timestamp();
  const ::flow::access::Timestamp& timestamp() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::Timestamp* release_timestamp();
  ::flow::access::Timestamp* mutable_timestamp();
  void set_allocated_timestamp(::flow::access::Timestamp* timestamp);
  private:
  const ::flow::access::Timestamp& _internal_timestamp() const;
  ::flow::access::Timestamp* _internal_mutable_timestamp();
  public:
  void unsafe_arena_set_allocated_timestamp(
      ::flow::access::Timestamp* timestamp);
  ::flow::access::Timestamp* unsafe_arena_release_timestamp();

  // uint64 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Block)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::CollectionGuarantee > collection_guarantees_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::BlockSeal > block_seals_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signatures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  ::flow::access::Timestamp* timestamp_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class BlockHeader final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockHeader) */ {
 public:
  inline BlockHeader() : BlockHeader(nullptr) {}
  ~BlockHeader() override;
  explicit constexpr BlockHeader(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockHeader(const BlockHeader& from);
  BlockHeader(BlockHeader&& from) noexcept
    : BlockHeader() {
    *this = ::std::move(from);
  }

  inline BlockHeader& operator=(const BlockHeader& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockHeader& operator=(BlockHeader&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockHeader& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockHeader* internal_default_instance() {
    return reinterpret_cast<const BlockHeader*>(
               &_BlockHeader_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    35;

  friend void swap(BlockHeader& a, BlockHeader& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockHeader* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockHeader* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockHeader* New() const final {
    return new BlockHeader();
  }

  BlockHeader* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockHeader>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockHeader& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockHeader& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockHeader* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockHeader";
  }
  protected:
  explicit BlockHeader(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kIdFieldNumber = 1,
    kParentIdFieldNumber = 2,
    kHeightFieldNumber = 3,
  };
  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // bytes parent_id = 2;
  void clear_parent_id();
  const std::string& parent_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_parent_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_parent_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_parent_id();
  void set_allocated_parent_id(std::string* parent_id);
  private:
  const std::string& _internal_parent_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_parent_id(const std::string& value);
  std::string* _internal_mutable_parent_id();
  public:

  // uint64 height = 3;
  void clear_height();
  ::PROTOBUF_NAMESPACE_ID::uint64 height() const;
  void set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_height() const;
  void _internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.BlockHeader)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr parent_id_;
  ::PROTOBUF_NAMESPACE_ID::uint64 height_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class BlockSeal final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.BlockSeal) */ {
 public:
  inline BlockSeal() : BlockSeal(nullptr) {}
  ~BlockSeal() override;
  explicit constexpr BlockSeal(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  BlockSeal(const BlockSeal& from);
  BlockSeal(BlockSeal&& from) noexcept
    : BlockSeal() {
    *this = ::std::move(from);
  }

  inline BlockSeal& operator=(const BlockSeal& from) {
    CopyFrom(from);
    return *this;
  }
  inline BlockSeal& operator=(BlockSeal&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const BlockSeal& default_instance() {
    return *internal_default_instance();
  }
  static inline const BlockSeal* internal_default_instance() {
    return reinterpret_cast<const BlockSeal*>(
               &_BlockSeal_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    36;

  friend void swap(BlockSeal& a, BlockSeal& b) {
    a.Swap(&b);
  }
  inline void Swap(BlockSeal* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(BlockSeal* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline BlockSeal* New() const final {
    return new BlockSeal();
  }

  BlockSeal* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<BlockSeal>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const BlockSeal& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const BlockSeal& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BlockSeal* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.BlockSeal";
  }
  protected:
  explicit BlockSeal(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kExecutionReceiptSignaturesFieldNumber = 3,
    kResultApprovalSignaturesFieldNumber = 4,
    kBlockIdFieldNumber = 1,
    kExecutionReceiptIdFieldNumber = 2,
  };
  // repeated bytes execution_receipt_signatures = 3;
  int execution_receipt_signatures_size() const;
  private:
  int _internal_execution_receipt_signatures_size() const;
  public:
  void clear_execution_receipt_signatures();
  const std::string& execution_receipt_signatures(int index) const;
  std::string* mutable_execution_receipt_signatures(int index);
  void set_execution_receipt_signatures(int index, const std::string& value);
  void set_execution_receipt_signatures(int index, std::string&& value);
  void set_execution_receipt_signatures(int index, const char* value);
  void set_execution_receipt_signatures(int index, const void* value, size_t size);
  std::string* add_execution_receipt_signatures();
  void add_execution_receipt_signatures(const std::string& value);
  void add_execution_receipt_signatures(std::string&& value);
  void add_execution_receipt_signatures(const char* value);
  void add_execution_receipt_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& execution_receipt_signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_execution_receipt_signatures();
  private:
  const std::string& _internal_execution_receipt_signatures(int index) const;
  std::string* _internal_add_execution_receipt_signatures();
  public:

  // repeated bytes result_approval_signatures = 4;
  int result_approval_signatures_size() const;
  private:
  int _internal_result_approval_signatures_size() const;
  public:
  void clear_result_approval_signatures();
  const std::string& result_approval_signatures(int index) const;
  std::string* mutable_result_approval_signatures(int index);
  void set_result_approval_signatures(int index, const std::string& value);
  void set_result_approval_signatures(int index, std::string&& value);
  void set_result_approval_signatures(int index, const char* value);
  void set_result_approval_signatures(int index, const void* value, size_t size);
  std::string* add_result_approval_signatures();
  void add_result_approval_signatures(const std::string& value);
  void add_result_approval_signatures(std::string&& value);
  void add_result_approval_signatures(const char* value);
  void add_result_approval_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& result_approval_signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_result_approval_signatures();
  private:
  const std::string& _internal_result_approval_signatures(int index) const;
  std::string* _internal_add_result_approval_signatures();
  public:

  // bytes block_id = 1;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes execution_receipt_id = 2;
  void clear_execution_receipt_id();
  const std::string& execution_receipt_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_execution_receipt_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_execution_receipt_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_execution_receipt_id();
  void set_allocated_execution_receipt_id(std::string* execution_receipt_id);
  private:
  const std::string& _internal_execution_receipt_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_execution_receipt_id(const std::string& value);
  std::string* _internal_mutable_execution_receipt_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.BlockSeal)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> execution_receipt_signatures_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> result_approval_signatures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr execution_receipt_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Collection final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Collection) */ {
 public:
  inline Collection() : Collection(nullptr) {}
  ~Collection() override;
  explicit constexpr Collection(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Collection(const Collection& from);
  Collection(Collection&& from) noexcept
    : Collection() {
    *this = ::std::move(from);
  }

  inline Collection& operator=(const Collection& from) {
    CopyFrom(from);
    return *this;
  }
  inline Collection& operator=(Collection&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Collection& default_instance() {
    return *internal_default_instance();
  }
  static inline const Collection* internal_default_instance() {
    return reinterpret_cast<const Collection*>(
               &_Collection_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    37;

  friend void swap(Collection& a, Collection& b) {
    a.Swap(&b);
  }
  inline void Swap(Collection* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Collection* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Collection* New() const final {
    return new Collection();
  }

  Collection* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Collection>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Collection& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Collection& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Collection* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Collection";
  }
  protected:
  explicit Collection(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTransactionIdsFieldNumber = 2,
    kIdFieldNumber = 1,
  };
  // repeated bytes transaction_ids = 2;
  int transaction_ids_size() const;
  private:
  int _internal_transaction_ids_size() const;
  public:
  void clear_transaction_ids();
  const std::string& transaction_ids(int index) const;
  std::string* mutable_transaction_ids(int index);
  void set_transaction_ids(int index, const std::string& value);
  void set_transaction_ids(int index, std::string&& value);
  void set_transaction_ids(int index, const char* value);
  void set_transaction_ids(int index, const void* value, size_t size);
  std::string* add_transaction_ids();
  void add_transaction_ids(const std::string& value);
  void add_transaction_ids(std::string&& value);
  void add_transaction_ids(const char* value);
  void add_transaction_ids(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& transaction_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_transaction_ids();
  private:
  const std::string& _internal_transaction_ids(int index) const;
  std::string* _internal_add_transaction_ids();
  public:

  // bytes id = 1;
  void clear_id();
  const std::string& id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_id();
  void set_allocated_id(std::string* id);
  private:
  const std::string& _internal_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(const std::string& value);
  std::string* _internal_mutable_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Collection)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> transaction_ids_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class CollectionGuarantee final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.CollectionGuarantee) */ {
 public:
  inline CollectionGuarantee() : CollectionGuarantee(nullptr) {}
  ~CollectionGuarantee() override;
  explicit constexpr CollectionGuarantee(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CollectionGuarantee(const CollectionGuarantee& from);
  CollectionGuarantee(CollectionGuarantee&& from) noexcept
    : CollectionGuarantee() {
    *this = ::std::move(from);
  }

  inline CollectionGuarantee& operator=(const CollectionGuarantee& from) {
    CopyFrom(from);
    return *this;
  }
  inline CollectionGuarantee& operator=(CollectionGuarantee&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const CollectionGuarantee& default_instance() {
    return *internal_default_instance();
  }
  static inline const CollectionGuarantee* internal_default_instance() {
    return reinterpret_cast<const CollectionGuarantee*>(
               &_CollectionGuarantee_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    38;

  friend void swap(CollectionGuarantee& a, CollectionGuarantee& b) {
    a.Swap(&b);
  }
  inline void Swap(CollectionGuarantee* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CollectionGuarantee* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline CollectionGuarantee* New() const final {
    return new CollectionGuarantee();
  }

  CollectionGuarantee* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<CollectionGuarantee>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const CollectionGuarantee& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const CollectionGuarantee& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(CollectionGuarantee* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.CollectionGuarantee";
  }
  protected:
  explicit CollectionGuarantee(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSignaturesFieldNumber = 2,
    kCollectionIdFieldNumber = 1,
  };
  // repeated bytes signatures = 2;
  int signatures_size() const;
  private:
  int _internal_signatures_size() const;
  public:
  void clear_signatures();
  const std::string& signatures(int index) const;
  std::string* mutable_signatures(int index);
  void set_signatures(int index, const std::string& value);
  void set_signatures(int index, std::string&& value);
  void set_signatures(int index, const char* value);
  void set_signatures(int index, const void* value, size_t size);
  std::string* add_signatures();
  void add_signatures(const std::string& value);
  void add_signatures(std::string&& value);
  void add_signatures(const char* value);
  void add_signatures(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& signatures() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_signatures();
  private:
  const std::string& _internal_signatures(int index) const;
  std::string* _internal_add_signatures();
  public:

  // bytes collection_id = 1;
  void clear_collection_id();
  const std::string& collection_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_collection_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_collection_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_collection_id();
  void set_allocated_collection_id(std::string* collection_id);
  private:
  const std::string& _internal_collection_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_collection_id(const std::string& value);
  std::string* _internal_mutable_collection_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.CollectionGuarantee)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> signatures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr collection_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Transaction final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Transaction) */ {
 public:
  inline Transaction() : Transaction(nullptr) {}
  ~Transaction() override;
  explicit constexpr Transaction(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Transaction(const Transaction& from);
  Transaction(Transaction&& from) noexcept
    : Transaction() {
    *this = ::std::move(from);
  }

  inline Transaction& operator=(const Transaction& from) {
    CopyFrom(from);
    return *this;
  }
  inline Transaction& operator=(Transaction&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Transaction& default_instance() {
    return *internal_default_instance();
  }
  static inline const Transaction* internal_default_instance() {
    return reinterpret_cast<const Transaction*>(
               &_Transaction_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    39;

  friend void swap(Transaction& a, Transaction& b) {
    a.Swap(&b);
  }
  inline void Swap(Transaction* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Transaction* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Transaction* New() const final {
    return new Transaction();
  }

  Transaction* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Transaction>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Transaction& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Transaction& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Transaction* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Transaction";
  }
  protected:
  explicit Transaction(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArgumentsFieldNumber = 2,
    kAuthorizersFieldNumber = 7,
    kPayloadSignaturesFieldNumber = 8,
    kEnvelopeSignaturesFieldNumber = 9,
    kScriptFieldNumber = 1,
    kReferenceBlockIdFieldNumber = 3,
    kPayerFieldNumber = 6,
    kProposalKeyFieldNumber = 5,
    kGasLimitFieldNumber = 4,
  };
  // repeated bytes arguments = 2;
  int arguments_size() const;
  private:
  int _internal_arguments_size() const;
  public:
  void clear_arguments();
  const std::string& arguments(int index) const;
  std::string* mutable_arguments(int index);
  void set_arguments(int index, const std::string& value);
  void set_arguments(int index, std::string&& value);
  void set_arguments(int index, const char* value);
  void set_arguments(int index, const void* value, size_t size);
  std::string* add_arguments();
  void add_arguments(const std::string& value);
  void add_arguments(std::string&& value);
  void add_arguments(const char* value);
  void add_arguments(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& arguments() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_arguments();
  private:
  const std::string& _internal_arguments(int index) const;
  std::string* _internal_add_arguments();
  public:

  // repeated bytes authorizers = 7;
  int authorizers_size() const;
  private:
  int _internal_authorizers_size() const;
  public:
  void clear_authorizers();
  const std::string& authorizers(int index) const;
  std::string* mutable_authorizers(int index);
  void set_authorizers(int index, const std::string& value);
  void set_authorizers(int index, std::string&& value);
  void set_authorizers(int index, const char* value);
  void set_authorizers(int index, const void* value, size_t size);
  std::string* add_authorizers();
  void add_authorizers(const std::string& value);
  void add_authorizers(std::string&& value);
  void add_authorizers(const char* value);
  void add_authorizers(const void* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& authorizers() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_authorizers();
  private:
  const std::string& _internal_authorizers(int index) const;
  std::string* _internal_add_authorizers();
  public:

  // repeated .flow.access.TransactionSignature payload_signatures = 8;
  int payload_signatures_size() const;
  private:
  int _internal_payload_signatures_size() const;
  public:
  void clear_payload_signatures();
  ::flow::access::TransactionSignature* mutable_payload_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >*
      mutable_payload_signatures();
  private:
  const ::flow::access::TransactionSignature& _internal_payload_signatures(int index) const;
  ::flow::access::TransactionSignature* _internal_add_payload_signatures();
  public:
  const ::flow::access::TransactionSignature& payload_signatures(int index) const;
  ::flow::access::TransactionSignature* add_payload_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >&
      payload_signatures() const;

  // repeated .flow.access.TransactionSignature envelope_signatures = 9;
  int envelope_signatures_size() const;
  private:
  int _internal_envelope_signatures_size() const;
  public:
  void clear_envelope_signatures();
  ::flow::access::TransactionSignature* mutable_envelope_signatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >*
      mutable_envelope_signatures();
  private:
  const ::flow::access::TransactionSignature& _internal_envelope_signatures(int index) const;
  ::flow::access::TransactionSignature* _internal_add_envelope_signatures();
  public:
  const ::flow::access::TransactionSignature& envelope_signatures(int index) const;
  ::flow::access::TransactionSignature* add_envelope_signatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >&
      envelope_signatures() const;

  // bytes script = 1;
  void clear_script();
  const std::string& script() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_script(ArgT0&& arg0, ArgT... args);
  std::string* mutable_script();
  PROTOBUF_MUST_USE_RESULT std::string* release_script();
  void set_allocated_script(std::string* script);
  private:
  const std::string& _internal_script() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_script(const std::string& value);
  std::string* _internal_mutable_script();
  public:

  // bytes reference_block_id = 3;
  void clear_reference_block_id();
  const std::string& reference_block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_reference_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_reference_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_reference_block_id();
  void set_allocated_reference_block_id(std::string* reference_block_id);
  private:
  const std::string& _internal_reference_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_reference_block_id(const std::string& value);
  std::string* _internal_mutable_reference_block_id();
  public:

  // bytes payer = 6;
  void clear_payer();
  const std::string& payer() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payer(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payer();
  PROTOBUF_MUST_USE_RESULT std::string* release_payer();
  void set_allocated_payer(std::string* payer);
  private:
  const std::string& _internal_payer() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payer(const std::string& value);
  std::string* _internal_mutable_payer();
  public:

  // .flow.access.TransactionProposalKey proposal_key = 5;
  bool has_proposal_key() const;
  private:
  bool _internal_has_proposal_key() const;
  public:
  void clear_proposal_key();
  const ::flow::access::TransactionProposalKey& proposal_key() const;
  PROTOBUF_MUST_USE_RESULT ::flow::access::TransactionProposalKey* release_proposal_key();
  ::flow::access::TransactionProposalKey* mutable_proposal_key();
  void set_allocated_proposal_key(::flow::access::TransactionProposalKey* proposal_key);
  private:
  const ::flow::access::TransactionProposalKey& _internal_proposal_key() const;
  ::flow::access::TransactionProposalKey* _internal_mutable_proposal_key();
  public:
  void unsafe_arena_set_allocated_proposal_key(
      ::flow::access::TransactionProposalKey* proposal_key);
  ::flow::access::TransactionProposalKey* unsafe_arena_release_proposal_key();

  // uint64 gas_limit = 4;
  void clear_gas_limit();
  ::PROTOBUF_NAMESPACE_ID::uint64 gas_limit() const;
  void set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_gas_limit() const;
  void _internal_set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Transaction)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> arguments_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> authorizers_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature > payload_signatures_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature > envelope_signatures_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr script_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr reference_block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payer_;
  ::flow::access::TransactionProposalKey* proposal_key_;
  ::PROTOBUF_NAMESPACE_ID::uint64 gas_limit_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class TransactionProposalKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionProposalKey) */ {
 public:
  inline TransactionProposalKey() : TransactionProposalKey(nullptr) {}
  ~TransactionProposalKey() override;
  explicit constexpr TransactionProposalKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionProposalKey(const TransactionProposalKey& from);
  TransactionProposalKey(TransactionProposalKey&& from) noexcept
    : TransactionProposalKey() {
    *this = ::std::move(from);
  }

  inline TransactionProposalKey& operator=(const TransactionProposalKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionProposalKey& operator=(TransactionProposalKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionProposalKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionProposalKey* internal_default_instance() {
    return reinterpret_cast<const TransactionProposalKey*>(
               &_TransactionProposalKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    40;

  friend void swap(TransactionProposalKey& a, TransactionProposalKey& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionProposalKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionProposalKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionProposalKey* New() const final {
    return new TransactionProposalKey();
  }

  TransactionProposalKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionProposalKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionProposalKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionProposalKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionProposalKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionProposalKey";
  }
  protected:
  explicit TransactionProposalKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kSequenceNumberFieldNumber = 3,
    kKeyIdFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // uint64 sequence_number = 3;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint32 key_id = 2;
  void clear_key_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_id() const;
  void set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_id() const;
  void _internal_set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.TransactionProposalKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::uint64 sequence_number_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class TransactionSignature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.TransactionSignature) */ {
 public:
  inline TransactionSignature() : TransactionSignature(nullptr) {}
  ~TransactionSignature() override;
  explicit constexpr TransactionSignature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TransactionSignature(const TransactionSignature& from);
  TransactionSignature(TransactionSignature&& from) noexcept
    : TransactionSignature() {
    *this = ::std::move(from);
  }

  inline TransactionSignature& operator=(const TransactionSignature& from) {
    CopyFrom(from);
    return *this;
  }
  inline TransactionSignature& operator=(TransactionSignature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const TransactionSignature& default_instance() {
    return *internal_default_instance();
  }
  static inline const TransactionSignature* internal_default_instance() {
    return reinterpret_cast<const TransactionSignature*>(
               &_TransactionSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    41;

  friend void swap(TransactionSignature& a, TransactionSignature& b) {
    a.Swap(&b);
  }
  inline void Swap(TransactionSignature* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TransactionSignature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline TransactionSignature* New() const final {
    return new TransactionSignature();
  }

  TransactionSignature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<TransactionSignature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const TransactionSignature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const TransactionSignature& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TransactionSignature* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.TransactionSignature";
  }
  protected:
  explicit TransactionSignature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAddressFieldNumber = 1,
    kSignatureFieldNumber = 3,
    kKeyIdFieldNumber = 2,
  };
  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes signature = 3;
  void clear_signature();
  const std::string& signature() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_signature(ArgT0&& arg0, ArgT... args);
  std::string* mutable_signature();
  PROTOBUF_MUST_USE_RESULT std::string* release_signature();
  void set_allocated_signature(std::string* signature);
  private:
  const std::string& _internal_signature() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_signature(const std::string& value);
  std::string* _internal_mutable_signature();
  public:

  // uint32 key_id = 2;
  void clear_key_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 key_id() const;
  void set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_key_id() const;
  void _internal_set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.TransactionSignature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr signature_;
  ::PROTOBUF_NAMESPACE_ID::uint32 key_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Account_ContractsEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_ContractsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<Account_ContractsEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  Account_ContractsEntry_DoNotUse();
  explicit constexpr Account_ContractsEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit Account_ContractsEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const Account_ContractsEntry_DoNotUse& other);
  static const Account_ContractsEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const Account_ContractsEntry_DoNotUse*>(&_Account_ContractsEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "flow.access.Account.ContractsEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
};

// -------------------------------------------------------------------

class Account final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Account) */ {
 public:
  inline Account() : Account(nullptr) {}
  ~Account() override;
  explicit constexpr Account(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Account(const Account& from);
  Account(Account&& from) noexcept
    : Account() {
    *this = ::std::move(from);
  }

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }
  inline Account& operator=(Account&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Account& default_instance() {
    return *internal_default_instance();
  }
  static inline const Account* internal_default_instance() {
    return reinterpret_cast<const Account*>(
               &_Account_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    43;

  friend void swap(Account& a, Account& b) {
    a.Swap(&b);
  }
  inline void Swap(Account* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Account* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Account* New() const final {
    return new Account();
  }

  Account* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Account>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Account& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Account& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Account* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Account";
  }
  protected:
  explicit Account(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kKeysFieldNumber = 4,
    kContractsFieldNumber = 5,
    kAddressFieldNumber = 1,
    kCodeFieldNumber = 3,
    kBalanceFieldNumber = 2,
  };
  // repeated .flow.access.AccountKey keys = 4;
  int keys_size() const;
  private:
  int _internal_keys_size() const;
  public:
  void clear_keys();
  ::flow::access::AccountKey* mutable_keys(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::AccountKey >*
      mutable_keys();
  private:
  const ::flow::access::AccountKey& _internal_keys(int index) const;
  ::flow::access::AccountKey* _internal_add_keys();
  public:
  const ::flow::access::AccountKey& keys(int index) const;
  ::flow::access::AccountKey* add_keys();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::AccountKey >&
      keys() const;

  // map<string, bytes> contracts = 5;
  int contracts_size() const;
  private:
  int _internal_contracts_size() const;
  public:
  void clear_contracts();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_contracts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_contracts();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      contracts() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_contracts();

  // bytes address = 1;
  void clear_address();
  const std::string& address() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_address(ArgT0&& arg0, ArgT... args);
  std::string* mutable_address();
  PROTOBUF_MUST_USE_RESULT std::string* release_address();
  void set_allocated_address(std::string* address);
  private:
  const std::string& _internal_address() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_address(const std::string& value);
  std::string* _internal_mutable_address();
  public:

  // bytes code = 3;
  void clear_code();
  const std::string& code() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_code(ArgT0&& arg0, ArgT... args);
  std::string* mutable_code();
  PROTOBUF_MUST_USE_RESULT std::string* release_code();
  void set_allocated_code(std::string* code);
  private:
  const std::string& _internal_code() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_code(const std::string& value);
  std::string* _internal_mutable_code();
  public:

  // uint64 balance = 2;
  void clear_balance();
  ::PROTOBUF_NAMESPACE_ID::uint64 balance() const;
  void set_balance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_balance() const;
  void _internal_set_balance(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Account)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::AccountKey > keys_;
  ::PROTOBUF_NAMESPACE_ID::internal::MapField<
      Account_ContractsEntry_DoNotUse,
      std::string, std::string,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> contracts_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr address_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr code_;
  ::PROTOBUF_NAMESPACE_ID::uint64 balance_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class AccountKey final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.AccountKey) */ {
 public:
  inline AccountKey() : AccountKey(nullptr) {}
  ~AccountKey() override;
  explicit constexpr AccountKey(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  AccountKey(const AccountKey& from);
  AccountKey(AccountKey&& from) noexcept
    : AccountKey() {
    *this = ::std::move(from);
  }

  inline AccountKey& operator=(const AccountKey& from) {
    CopyFrom(from);
    return *this;
  }
  inline AccountKey& operator=(AccountKey&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const AccountKey& default_instance() {
    return *internal_default_instance();
  }
  static inline const AccountKey* internal_default_instance() {
    return reinterpret_cast<const AccountKey*>(
               &_AccountKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    44;

  friend void swap(AccountKey& a, AccountKey& b) {
    a.Swap(&b);
  }
  inline void Swap(AccountKey* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(AccountKey* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline AccountKey* New() const final {
    return new AccountKey();
  }

  AccountKey* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<AccountKey>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const AccountKey& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const AccountKey& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AccountKey* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.AccountKey";
  }
  protected:
  explicit AccountKey(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kPublicKeyFieldNumber = 2,
    kIdFieldNumber = 1,
    kSignAlgoFieldNumber = 3,
    kHashAlgoFieldNumber = 4,
    kWeightFieldNumber = 5,
    kSequenceNumberFieldNumber = 6,
    kRevokedFieldNumber = 7,
  };
  // bytes public_key = 2;
  void clear_public_key();
  const std::string& public_key() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_public_key(ArgT0&& arg0, ArgT... args);
  std::string* mutable_public_key();
  PROTOBUF_MUST_USE_RESULT std::string* release_public_key();
  void set_allocated_public_key(std::string* public_key);
  private:
  const std::string& _internal_public_key() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_public_key(const std::string& value);
  std::string* _internal_mutable_public_key();
  public:

  // uint32 id = 1;
  void clear_id();
  ::PROTOBUF_NAMESPACE_ID::uint32 id() const;
  void set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_id() const;
  void _internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 sign_algo = 3;
  void clear_sign_algo();
  ::PROTOBUF_NAMESPACE_ID::uint32 sign_algo() const;
  void set_sign_algo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sign_algo() const;
  void _internal_set_sign_algo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 hash_algo = 4;
  void clear_hash_algo();
  ::PROTOBUF_NAMESPACE_ID::uint32 hash_algo() const;
  void set_hash_algo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_hash_algo() const;
  void _internal_set_hash_algo(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 weight = 5;
  void clear_weight();
  ::PROTOBUF_NAMESPACE_ID::uint32 weight() const;
  void set_weight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_weight() const;
  void _internal_set_weight(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 sequence_number = 6;
  void clear_sequence_number();
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number() const;
  void set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_sequence_number() const;
  void _internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // bool revoked = 7;
  void clear_revoked();
  bool revoked() const;
  void set_revoked(bool value);
  private:
  bool _internal_revoked() const;
  void _internal_set_revoked(bool value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.AccountKey)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr public_key_;
  ::PROTOBUF_NAMESPACE_ID::uint32 id_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sign_algo_;
  ::PROTOBUF_NAMESPACE_ID::uint32 hash_algo_;
  ::PROTOBUF_NAMESPACE_ID::uint32 weight_;
  ::PROTOBUF_NAMESPACE_ID::uint32 sequence_number_;
  bool revoked_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Event final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Event) */ {
 public:
  inline Event() : Event(nullptr) {}
  ~Event() override;
  explicit constexpr Event(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Event(const Event& from);
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  inline Event& operator=(Event&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Event& default_instance() {
    return *internal_default_instance();
  }
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    45;

  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }
  inline void Swap(Event* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Event* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return new Event();
  }

  Event* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Event& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Event& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Event";
  }
  protected:
  explicit Event(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kTransactionIdFieldNumber = 2,
    kPayloadFieldNumber = 5,
    kTransactionIndexFieldNumber = 3,
    kEventIndexFieldNumber = 4,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes transaction_id = 2;
  void clear_transaction_id();
  const std::string& transaction_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_transaction_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_transaction_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_transaction_id();
  void set_allocated_transaction_id(std::string* transaction_id);
  private:
  const std::string& _internal_transaction_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_transaction_id(const std::string& value);
  std::string* _internal_mutable_transaction_id();
  public:

  // bytes payload = 5;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // uint32 transaction_index = 3;
  void clear_transaction_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 transaction_index() const;
  void set_transaction_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_transaction_index() const;
  void _internal_set_transaction_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // uint32 event_index = 4;
  void clear_event_index();
  ::PROTOBUF_NAMESPACE_ID::uint32 event_index() const;
  void set_event_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint32 _internal_event_index() const;
  void _internal_set_event_index(::PROTOBUF_NAMESPACE_ID::uint32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Event)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr transaction_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  ::PROTOBUF_NAMESPACE_ID::uint32 transaction_index_;
  ::PROTOBUF_NAMESPACE_ID::uint32 event_index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ExecutionResult final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ExecutionResult) */ {
 public:
  inline ExecutionResult() : ExecutionResult(nullptr) {}
  ~ExecutionResult() override;
  explicit constexpr ExecutionResult(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ExecutionResult(const ExecutionResult& from);
  ExecutionResult(ExecutionResult&& from) noexcept
    : ExecutionResult() {
    *this = ::std::move(from);
  }

  inline ExecutionResult& operator=(const ExecutionResult& from) {
    CopyFrom(from);
    return *this;
  }
  inline ExecutionResult& operator=(ExecutionResult&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ExecutionResult& default_instance() {
    return *internal_default_instance();
  }
  static inline const ExecutionResult* internal_default_instance() {
    return reinterpret_cast<const ExecutionResult*>(
               &_ExecutionResult_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    46;

  friend void swap(ExecutionResult& a, ExecutionResult& b) {
    a.Swap(&b);
  }
  inline void Swap(ExecutionResult* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ExecutionResult* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ExecutionResult* New() const final {
    return new ExecutionResult();
  }

  ExecutionResult* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ExecutionResult>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ExecutionResult& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ExecutionResult& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExecutionResult* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ExecutionResult";
  }
  protected:
  explicit ExecutionResult(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kChunksFieldNumber = 3,
    kServiceEventsFieldNumber = 4,
    kPreviousResultIdFieldNumber = 1,
    kBlockIdFieldNumber = 2,
  };
  // repeated .flow.access.Chunk chunks = 3;
  int chunks_size() const;
  private:
  int _internal_chunks_size() const;
  public:
  void clear_chunks();
  ::flow::access::Chunk* mutable_chunks(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Chunk >*
      mutable_chunks();
  private:
  const ::flow::access::Chunk& _internal_chunks(int index) const;
  ::flow::access::Chunk* _internal_add_chunks();
  public:
  const ::flow::access::Chunk& chunks(int index) const;
  ::flow::access::Chunk* add_chunks();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Chunk >&
      chunks() const;

  // repeated .flow.access.ServiceEvent service_events = 4;
  int service_events_size() const;
  private:
  int _internal_service_events_size() const;
  public:
  void clear_service_events();
  ::flow::access::ServiceEvent* mutable_service_events(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::ServiceEvent >*
      mutable_service_events();
  private:
  const ::flow::access::ServiceEvent& _internal_service_events(int index) const;
  ::flow::access::ServiceEvent* _internal_add_service_events();
  public:
  const ::flow::access::ServiceEvent& service_events(int index) const;
  ::flow::access::ServiceEvent* add_service_events();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::ServiceEvent >&
      service_events() const;

  // bytes previous_result_id = 1;
  void clear_previous_result_id();
  const std::string& previous_result_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_previous_result_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_previous_result_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_previous_result_id();
  void set_allocated_previous_result_id(std::string* previous_result_id);
  private:
  const std::string& _internal_previous_result_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_previous_result_id(const std::string& value);
  std::string* _internal_mutable_previous_result_id();
  public:

  // bytes block_id = 2;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ExecutionResult)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Chunk > chunks_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::ServiceEvent > service_events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr previous_result_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Chunk final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Chunk) */ {
 public:
  inline Chunk() : Chunk(nullptr) {}
  ~Chunk() override;
  explicit constexpr Chunk(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Chunk(const Chunk& from);
  Chunk(Chunk&& from) noexcept
    : Chunk() {
    *this = ::std::move(from);
  }

  inline Chunk& operator=(const Chunk& from) {
    CopyFrom(from);
    return *this;
  }
  inline Chunk& operator=(Chunk&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Chunk& default_instance() {
    return *internal_default_instance();
  }
  static inline const Chunk* internal_default_instance() {
    return reinterpret_cast<const Chunk*>(
               &_Chunk_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    47;

  friend void swap(Chunk& a, Chunk& b) {
    a.Swap(&b);
  }
  inline void Swap(Chunk* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Chunk* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Chunk* New() const final {
    return new Chunk();
  }

  Chunk* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Chunk>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Chunk& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Chunk& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Chunk* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Chunk";
  }
  protected:
  explicit Chunk(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStartStateFieldNumber = 1,
    kEventCollectionFieldNumber = 2,
    kBlockIdFieldNumber = 3,
    kEndStateFieldNumber = 7,
    kTotalComputationUsedFieldNumber = 4,
    kNumberOfTransactionsFieldNumber = 5,
    kIndexFieldNumber = 6,
  };
  // bytes start_state = 1;
  void clear_start_state();
  const std::string& start_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_start_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_start_state();
  PROTOBUF_MUST_USE_RESULT std::string* release_start_state();
  void set_allocated_start_state(std::string* start_state);
  private:
  const std::string& _internal_start_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_start_state(const std::string& value);
  std::string* _internal_mutable_start_state();
  public:

  // bytes event_collection = 2;
  void clear_event_collection();
  const std::string& event_collection() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_event_collection(ArgT0&& arg0, ArgT... args);
  std::string* mutable_event_collection();
  PROTOBUF_MUST_USE_RESULT std::string* release_event_collection();
  void set_allocated_event_collection(std::string* event_collection);
  private:
  const std::string& _internal_event_collection() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_event_collection(const std::string& value);
  std::string* _internal_mutable_event_collection();
  public:

  // bytes block_id = 3;
  void clear_block_id();
  const std::string& block_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_block_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_block_id();
  PROTOBUF_MUST_USE_RESULT std::string* release_block_id();
  void set_allocated_block_id(std::string* block_id);
  private:
  const std::string& _internal_block_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_block_id(const std::string& value);
  std::string* _internal_mutable_block_id();
  public:

  // bytes end_state = 7;
  void clear_end_state();
  const std::string& end_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_end_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_end_state();
  PROTOBUF_MUST_USE_RESULT std::string* release_end_state();
  void set_allocated_end_state(std::string* end_state);
  private:
  const std::string& _internal_end_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_end_state(const std::string& value);
  std::string* _internal_mutable_end_state();
  public:

  // uint64 total_computation_used = 4;
  void clear_total_computation_used();
  ::PROTOBUF_NAMESPACE_ID::uint64 total_computation_used() const;
  void set_total_computation_used(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_total_computation_used() const;
  void _internal_set_total_computation_used(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 number_of_transactions = 5;
  void clear_number_of_transactions();
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_transactions() const;
  void set_number_of_transactions(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_number_of_transactions() const;
  void _internal_set_number_of_transactions(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // uint64 index = 6;
  void clear_index();
  ::PROTOBUF_NAMESPACE_ID::uint64 index() const;
  void set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::uint64 _internal_index() const;
  void _internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Chunk)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr start_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr event_collection_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr block_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr end_state_;
  ::PROTOBUF_NAMESPACE_ID::uint64 total_computation_used_;
  ::PROTOBUF_NAMESPACE_ID::uint64 number_of_transactions_;
  ::PROTOBUF_NAMESPACE_ID::uint64 index_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class ServiceEvent final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.ServiceEvent) */ {
 public:
  inline ServiceEvent() : ServiceEvent(nullptr) {}
  ~ServiceEvent() override;
  explicit constexpr ServiceEvent(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ServiceEvent(const ServiceEvent& from);
  ServiceEvent(ServiceEvent&& from) noexcept
    : ServiceEvent() {
    *this = ::std::move(from);
  }

  inline ServiceEvent& operator=(const ServiceEvent& from) {
    CopyFrom(from);
    return *this;
  }
  inline ServiceEvent& operator=(ServiceEvent&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const ServiceEvent& default_instance() {
    return *internal_default_instance();
  }
  static inline const ServiceEvent* internal_default_instance() {
    return reinterpret_cast<const ServiceEvent*>(
               &_ServiceEvent_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    48;

  friend void swap(ServiceEvent& a, ServiceEvent& b) {
    a.Swap(&b);
  }
  inline void Swap(ServiceEvent* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ServiceEvent* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline ServiceEvent* New() const final {
    return new ServiceEvent();
  }

  ServiceEvent* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<ServiceEvent>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const ServiceEvent& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const ServiceEvent& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ServiceEvent* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.ServiceEvent";
  }
  protected:
  explicit ServiceEvent(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTypeFieldNumber = 1,
    kPayloadFieldNumber = 2,
  };
  // string type = 1;
  void clear_type();
  const std::string& type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_type();
  PROTOBUF_MUST_USE_RESULT std::string* release_type();
  void set_allocated_type(std::string* type);
  private:
  const std::string& _internal_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_type(const std::string& value);
  std::string* _internal_mutable_type();
  public:

  // bytes payload = 2;
  void clear_payload();
  const std::string& payload() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_payload(ArgT0&& arg0, ArgT... args);
  std::string* mutable_payload();
  PROTOBUF_MUST_USE_RESULT std::string* release_payload();
  void set_allocated_payload(std::string* payload);
  private:
  const std::string& _internal_payload() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_payload(const std::string& value);
  std::string* _internal_mutable_payload();
  public:

  // @@protoc_insertion_point(class_scope:flow.access.ServiceEvent)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr type_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr payload_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// -------------------------------------------------------------------

class Timestamp final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:flow.access.Timestamp) */ {
 public:
  inline Timestamp() : Timestamp(nullptr) {}
  ~Timestamp() override;
  explicit constexpr Timestamp(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  Timestamp(const Timestamp& from);
  Timestamp(Timestamp&& from) noexcept
    : Timestamp() {
    *this = ::std::move(from);
  }

  inline Timestamp& operator=(const Timestamp& from) {
    CopyFrom(from);
    return *this;
  }
  inline Timestamp& operator=(Timestamp&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const Timestamp& default_instance() {
    return *internal_default_instance();
  }
  static inline const Timestamp* internal_default_instance() {
    return reinterpret_cast<const Timestamp*>(
               &_Timestamp_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    49;

  friend void swap(Timestamp& a, Timestamp& b) {
    a.Swap(&b);
  }
  inline void Swap(Timestamp* other) {
    if (other == this) return;
    if (GetOwningArena() == other->GetOwningArena()) {
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(Timestamp* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  inline Timestamp* New() const final {
    return new Timestamp();
  }

  Timestamp* New(::PROTOBUF_NAMESPACE_ID::Arena* arena) const final {
    return CreateMaybeMessage<Timestamp>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const Timestamp& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const Timestamp& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message*to, const ::PROTOBUF_NAMESPACE_ID::Message&from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  ::PROTOBUF_NAMESPACE_ID::uint8* _InternalSerialize(
      ::PROTOBUF_NAMESPACE_ID::uint8* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Timestamp* other);
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "flow.access.Timestamp";
  }
  protected:
  explicit Timestamp(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kSecondsFieldNumber = 1,
    kNanosFieldNumber = 2,
  };
  // int64 seconds = 1;
  void clear_seconds();
  ::PROTOBUF_NAMESPACE_ID::int64 seconds() const;
  void set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int64 _internal_seconds() const;
  void _internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value);
  public:

  // int32 nanos = 2;
  void clear_nanos();
  ::PROTOBUF_NAMESPACE_ID::int32 nanos() const;
  void set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value);
  private:
  ::PROTOBUF_NAMESPACE_ID::int32 _internal_nanos() const;
  void _internal_set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value);
  public:

  // @@protoc_insertion_point(class_scope:flow.access.Timestamp)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::int64 seconds_;
  ::PROTOBUF_NAMESPACE_ID::int32 nanos_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_flow_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// PingRequest

// -------------------------------------------------------------------

// PingResponse

// -------------------------------------------------------------------

// BlockHeaderResponse

// .flow.access.BlockHeader block = 1;
inline bool BlockHeaderResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockHeaderResponse::has_block() const {
  return _internal_has_block();
}
inline void BlockHeaderResponse::clear_block() {
  if (GetArenaForAllocation() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::flow::access::BlockHeader& BlockHeaderResponse::_internal_block() const {
  const ::flow::access::BlockHeader* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::BlockHeader&>(
      ::flow::access::_BlockHeader_default_instance_);
}
inline const ::flow::access::BlockHeader& BlockHeaderResponse::block() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockHeaderResponse.block)
  return _internal_block();
}
inline void BlockHeaderResponse::unsafe_arena_set_allocated_block(
    ::flow::access::BlockHeader* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.BlockHeaderResponse.block)
}
inline ::flow::access::BlockHeader* BlockHeaderResponse::release_block() {
  
  ::flow::access::BlockHeader* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::BlockHeader* BlockHeaderResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:flow.access.BlockHeaderResponse.block)
  
  ::flow::access::BlockHeader* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::flow::access::BlockHeader* BlockHeaderResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::BlockHeader>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::flow::access::BlockHeader* BlockHeaderResponse::mutable_block() {
  ::flow::access::BlockHeader* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockHeaderResponse.block)
  return _msg;
}
inline void BlockHeaderResponse::set_allocated_block(::flow::access::BlockHeader* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::BlockHeader>::GetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockHeaderResponse.block)
}

// -------------------------------------------------------------------

// GetLatestBlockHeaderRequest

// bool is_sealed = 1;
inline void GetLatestBlockHeaderRequest::clear_is_sealed() {
  is_sealed_ = false;
}
inline bool GetLatestBlockHeaderRequest::_internal_is_sealed() const {
  return is_sealed_;
}
inline bool GetLatestBlockHeaderRequest::is_sealed() const {
  // @@protoc_insertion_point(field_get:flow.access.GetLatestBlockHeaderRequest.is_sealed)
  return _internal_is_sealed();
}
inline void GetLatestBlockHeaderRequest::_internal_set_is_sealed(bool value) {
  
  is_sealed_ = value;
}
inline void GetLatestBlockHeaderRequest::set_is_sealed(bool value) {
  _internal_set_is_sealed(value);
  // @@protoc_insertion_point(field_set:flow.access.GetLatestBlockHeaderRequest.is_sealed)
}

// -------------------------------------------------------------------

// GetBlockHeaderByIdRequest

// bytes id = 1;
inline void GetBlockHeaderByIdRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetBlockHeaderByIdRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockHeaderByIdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockHeaderByIdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetBlockHeaderByIdRequest.id)
}
inline std::string* GetBlockHeaderByIdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetBlockHeaderByIdRequest.id)
  return _s;
}
inline const std::string& GetBlockHeaderByIdRequest::_internal_id() const {
  return id_.Get();
}
inline void GetBlockHeaderByIdRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIdRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBlockHeaderByIdRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetBlockHeaderByIdRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBlockHeaderByIdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetBlockHeaderByIdRequest.id)
}

// -------------------------------------------------------------------

// GetBlockHeaderByHeightRequest

// uint64 height = 1;
inline void GetBlockHeaderByHeightRequest::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockHeaderByHeightRequest::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockHeaderByHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockHeaderByHeightRequest.height)
  return _internal_height();
}
inline void GetBlockHeaderByHeightRequest::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void GetBlockHeaderByHeightRequest::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetBlockHeaderByHeightRequest.height)
}

// -------------------------------------------------------------------

// BlockResponse

// .flow.access.Block block = 1;
inline bool BlockResponse::_internal_has_block() const {
  return this != internal_default_instance() && block_ != nullptr;
}
inline bool BlockResponse::has_block() const {
  return _internal_has_block();
}
inline void BlockResponse::clear_block() {
  if (GetArenaForAllocation() == nullptr && block_ != nullptr) {
    delete block_;
  }
  block_ = nullptr;
}
inline const ::flow::access::Block& BlockResponse::_internal_block() const {
  const ::flow::access::Block* p = block_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Block&>(
      ::flow::access::_Block_default_instance_);
}
inline const ::flow::access::Block& BlockResponse::block() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockResponse.block)
  return _internal_block();
}
inline void BlockResponse::unsafe_arena_set_allocated_block(
    ::flow::access::Block* block) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_);
  }
  block_ = block;
  if (block) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.BlockResponse.block)
}
inline ::flow::access::Block* BlockResponse::release_block() {
  
  ::flow::access::Block* temp = block_;
  block_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Block* BlockResponse::unsafe_arena_release_block() {
  // @@protoc_insertion_point(field_release:flow.access.BlockResponse.block)
  
  ::flow::access::Block* temp = block_;
  block_ = nullptr;
  return temp;
}
inline ::flow::access::Block* BlockResponse::_internal_mutable_block() {
  
  if (block_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Block>(GetArenaForAllocation());
    block_ = p;
  }
  return block_;
}
inline ::flow::access::Block* BlockResponse::mutable_block() {
  ::flow::access::Block* _msg = _internal_mutable_block();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockResponse.block)
  return _msg;
}
inline void BlockResponse::set_allocated_block(::flow::access::Block* block) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_;
  }
  if (block) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Block>::GetOwningArena(block);
    if (message_arena != submessage_arena) {
      block = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block, submessage_arena);
    }
    
  } else {
    
  }
  block_ = block;
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockResponse.block)
}

// -------------------------------------------------------------------

// GetLatestBlockRequest

// bool is_sealed = 1;
inline void GetLatestBlockRequest::clear_is_sealed() {
  is_sealed_ = false;
}
inline bool GetLatestBlockRequest::_internal_is_sealed() const {
  return is_sealed_;
}
inline bool GetLatestBlockRequest::is_sealed() const {
  // @@protoc_insertion_point(field_get:flow.access.GetLatestBlockRequest.is_sealed)
  return _internal_is_sealed();
}
inline void GetLatestBlockRequest::_internal_set_is_sealed(bool value) {
  
  is_sealed_ = value;
}
inline void GetLatestBlockRequest::set_is_sealed(bool value) {
  _internal_set_is_sealed(value);
  // @@protoc_insertion_point(field_set:flow.access.GetLatestBlockRequest.is_sealed)
}

// -------------------------------------------------------------------

// GetBlockByIdRequest

// bytes id = 1;
inline void GetBlockByIdRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetBlockByIdRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockByIdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetBlockByIdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetBlockByIdRequest.id)
}
inline std::string* GetBlockByIdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetBlockByIdRequest.id)
  return _s;
}
inline const std::string& GetBlockByIdRequest::_internal_id() const {
  return id_.Get();
}
inline void GetBlockByIdRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetBlockByIdRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetBlockByIdRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetBlockByIdRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetBlockByIdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetBlockByIdRequest.id)
}

// -------------------------------------------------------------------

// GetBlockByHeightRequest

// uint64 height = 1;
inline void GetBlockByHeightRequest::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockByHeightRequest::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetBlockByHeightRequest::height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetBlockByHeightRequest.height)
  return _internal_height();
}
inline void GetBlockByHeightRequest::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void GetBlockByHeightRequest::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetBlockByHeightRequest.height)
}

// -------------------------------------------------------------------

// CollectionResponse

// .flow.access.Collection collection = 1;
inline bool CollectionResponse::_internal_has_collection() const {
  return this != internal_default_instance() && collection_ != nullptr;
}
inline bool CollectionResponse::has_collection() const {
  return _internal_has_collection();
}
inline void CollectionResponse::clear_collection() {
  if (GetArenaForAllocation() == nullptr && collection_ != nullptr) {
    delete collection_;
  }
  collection_ = nullptr;
}
inline const ::flow::access::Collection& CollectionResponse::_internal_collection() const {
  const ::flow::access::Collection* p = collection_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Collection&>(
      ::flow::access::_Collection_default_instance_);
}
inline const ::flow::access::Collection& CollectionResponse::collection() const {
  // @@protoc_insertion_point(field_get:flow.access.CollectionResponse.collection)
  return _internal_collection();
}
inline void CollectionResponse::unsafe_arena_set_allocated_collection(
    ::flow::access::Collection* collection) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(collection_);
  }
  collection_ = collection;
  if (collection) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.CollectionResponse.collection)
}
inline ::flow::access::Collection* CollectionResponse::release_collection() {
  
  ::flow::access::Collection* temp = collection_;
  collection_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Collection* CollectionResponse::unsafe_arena_release_collection() {
  // @@protoc_insertion_point(field_release:flow.access.CollectionResponse.collection)
  
  ::flow::access::Collection* temp = collection_;
  collection_ = nullptr;
  return temp;
}
inline ::flow::access::Collection* CollectionResponse::_internal_mutable_collection() {
  
  if (collection_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Collection>(GetArenaForAllocation());
    collection_ = p;
  }
  return collection_;
}
inline ::flow::access::Collection* CollectionResponse::mutable_collection() {
  ::flow::access::Collection* _msg = _internal_mutable_collection();
  // @@protoc_insertion_point(field_mutable:flow.access.CollectionResponse.collection)
  return _msg;
}
inline void CollectionResponse::set_allocated_collection(::flow::access::Collection* collection) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete collection_;
  }
  if (collection) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Collection>::GetOwningArena(collection);
    if (message_arena != submessage_arena) {
      collection = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, collection, submessage_arena);
    }
    
  } else {
    
  }
  collection_ = collection;
  // @@protoc_insertion_point(field_set_allocated:flow.access.CollectionResponse.collection)
}

// -------------------------------------------------------------------

// GetCollectionByIdRequest

// bytes id = 1;
inline void GetCollectionByIdRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetCollectionByIdRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetCollectionByIdRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetCollectionByIdRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetCollectionByIdRequest.id)
}
inline std::string* GetCollectionByIdRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetCollectionByIdRequest.id)
  return _s;
}
inline const std::string& GetCollectionByIdRequest::_internal_id() const {
  return id_.Get();
}
inline void GetCollectionByIdRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetCollectionByIdRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetCollectionByIdRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetCollectionByIdRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetCollectionByIdRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetCollectionByIdRequest.id)
}

// -------------------------------------------------------------------

// SendTransactionResponse

// bytes id = 1;
inline void SendTransactionResponse::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& SendTransactionResponse::id() const {
  // @@protoc_insertion_point(field_get:flow.access.SendTransactionResponse.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SendTransactionResponse::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.SendTransactionResponse.id)
}
inline std::string* SendTransactionResponse::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.SendTransactionResponse.id)
  return _s;
}
inline const std::string& SendTransactionResponse::_internal_id() const {
  return id_.Get();
}
inline void SendTransactionResponse::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* SendTransactionResponse::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* SendTransactionResponse::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.SendTransactionResponse.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void SendTransactionResponse::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.SendTransactionResponse.id)
}

// -------------------------------------------------------------------

// SendTransactionRequest

// .flow.access.Transaction transaction = 1;
inline bool SendTransactionRequest::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool SendTransactionRequest::has_transaction() const {
  return _internal_has_transaction();
}
inline void SendTransactionRequest::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::flow::access::Transaction& SendTransactionRequest::_internal_transaction() const {
  const ::flow::access::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Transaction&>(
      ::flow::access::_Transaction_default_instance_);
}
inline const ::flow::access::Transaction& SendTransactionRequest::transaction() const {
  // @@protoc_insertion_point(field_get:flow.access.SendTransactionRequest.transaction)
  return _internal_transaction();
}
inline void SendTransactionRequest::unsafe_arena_set_allocated_transaction(
    ::flow::access::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.SendTransactionRequest.transaction)
}
inline ::flow::access::Transaction* SendTransactionRequest::release_transaction() {
  
  ::flow::access::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Transaction* SendTransactionRequest::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:flow.access.SendTransactionRequest.transaction)
  
  ::flow::access::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::flow::access::Transaction* SendTransactionRequest::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::flow::access::Transaction* SendTransactionRequest::mutable_transaction() {
  ::flow::access::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:flow.access.SendTransactionRequest.transaction)
  return _msg;
}
inline void SendTransactionRequest::set_allocated_transaction(::flow::access::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:flow.access.SendTransactionRequest.transaction)
}

// -------------------------------------------------------------------

// GetTransactionRequest

// bytes id = 1;
inline void GetTransactionRequest::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& GetTransactionRequest::id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetTransactionRequest.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetTransactionRequest::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetTransactionRequest.id)
}
inline std::string* GetTransactionRequest::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetTransactionRequest.id)
  return _s;
}
inline const std::string& GetTransactionRequest::_internal_id() const {
  return id_.Get();
}
inline void GetTransactionRequest::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetTransactionRequest::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetTransactionRequest::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetTransactionRequest.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetTransactionRequest::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetTransactionRequest.id)
}

// -------------------------------------------------------------------

// TransactionResponse

// .flow.access.Transaction transaction = 1;
inline bool TransactionResponse::_internal_has_transaction() const {
  return this != internal_default_instance() && transaction_ != nullptr;
}
inline bool TransactionResponse::has_transaction() const {
  return _internal_has_transaction();
}
inline void TransactionResponse::clear_transaction() {
  if (GetArenaForAllocation() == nullptr && transaction_ != nullptr) {
    delete transaction_;
  }
  transaction_ = nullptr;
}
inline const ::flow::access::Transaction& TransactionResponse::_internal_transaction() const {
  const ::flow::access::Transaction* p = transaction_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Transaction&>(
      ::flow::access::_Transaction_default_instance_);
}
inline const ::flow::access::Transaction& TransactionResponse::transaction() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResponse.transaction)
  return _internal_transaction();
}
inline void TransactionResponse::unsafe_arena_set_allocated_transaction(
    ::flow::access::Transaction* transaction) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(transaction_);
  }
  transaction_ = transaction;
  if (transaction) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.TransactionResponse.transaction)
}
inline ::flow::access::Transaction* TransactionResponse::release_transaction() {
  
  ::flow::access::Transaction* temp = transaction_;
  transaction_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Transaction* TransactionResponse::unsafe_arena_release_transaction() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionResponse.transaction)
  
  ::flow::access::Transaction* temp = transaction_;
  transaction_ = nullptr;
  return temp;
}
inline ::flow::access::Transaction* TransactionResponse::_internal_mutable_transaction() {
  
  if (transaction_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Transaction>(GetArenaForAllocation());
    transaction_ = p;
  }
  return transaction_;
}
inline ::flow::access::Transaction* TransactionResponse::mutable_transaction() {
  ::flow::access::Transaction* _msg = _internal_mutable_transaction();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResponse.transaction)
  return _msg;
}
inline void TransactionResponse::set_allocated_transaction(::flow::access::Transaction* transaction) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete transaction_;
  }
  if (transaction) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Transaction>::GetOwningArena(transaction);
    if (message_arena != submessage_arena) {
      transaction = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, transaction, submessage_arena);
    }
    
  } else {
    
  }
  transaction_ = transaction;
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionResponse.transaction)
}

// -------------------------------------------------------------------

// TransactionResultResponse

// .flow.access.TransactionStatus status = 1;
inline void TransactionResultResponse::clear_status() {
  status_ = 0;
}
inline ::flow::access::TransactionStatus TransactionResultResponse::_internal_status() const {
  return static_cast< ::flow::access::TransactionStatus >(status_);
}
inline ::flow::access::TransactionStatus TransactionResultResponse::status() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.status)
  return _internal_status();
}
inline void TransactionResultResponse::_internal_set_status(::flow::access::TransactionStatus value) {
  
  status_ = value;
}
inline void TransactionResultResponse::set_status(::flow::access::TransactionStatus value) {
  _internal_set_status(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.status)
}

// uint32 status_code = 2;
inline void TransactionResultResponse::clear_status_code() {
  status_code_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionResultResponse::_internal_status_code() const {
  return status_code_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionResultResponse::status_code() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.status_code)
  return _internal_status_code();
}
inline void TransactionResultResponse::_internal_set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  status_code_ = value;
}
inline void TransactionResultResponse::set_status_code(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_status_code(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.status_code)
}

// string error_message = 3;
inline void TransactionResultResponse::clear_error_message() {
  error_message_.ClearToEmpty();
}
inline const std::string& TransactionResultResponse::error_message() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.error_message)
  return _internal_error_message();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionResultResponse::set_error_message(ArgT0&& arg0, ArgT... args) {
 
 error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionResultResponse.error_message)
}
inline std::string* TransactionResultResponse::mutable_error_message() {
  std::string* _s = _internal_mutable_error_message();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResultResponse.error_message)
  return _s;
}
inline const std::string& TransactionResultResponse::_internal_error_message() const {
  return error_message_.Get();
}
inline void TransactionResultResponse::_internal_set_error_message(const std::string& value) {
  
  error_message_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::_internal_mutable_error_message() {
  
  return error_message_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionResultResponse::release_error_message() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionResultResponse.error_message)
  return error_message_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionResultResponse::set_allocated_error_message(std::string* error_message) {
  if (error_message != nullptr) {
    
  } else {
    
  }
  error_message_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), error_message,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionResultResponse.error_message)
}

// repeated .flow.access.Event events = 4;
inline int TransactionResultResponse::_internal_events_size() const {
  return events_.size();
}
inline int TransactionResultResponse::events_size() const {
  return _internal_events_size();
}
inline void TransactionResultResponse::clear_events() {
  events_.Clear();
}
inline ::flow::access::Event* TransactionResultResponse::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionResultResponse.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >*
TransactionResultResponse::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.TransactionResultResponse.events)
  return &events_;
}
inline const ::flow::access::Event& TransactionResultResponse::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::access::Event& TransactionResultResponse::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionResultResponse.events)
  return _internal_events(index);
}
inline ::flow::access::Event* TransactionResultResponse::_internal_add_events() {
  return events_.Add();
}
inline ::flow::access::Event* TransactionResultResponse::add_events() {
  ::flow::access::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.access.TransactionResultResponse.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >&
TransactionResultResponse::events() const {
  // @@protoc_insertion_point(field_list:flow.access.TransactionResultResponse.events)
  return events_;
}

// -------------------------------------------------------------------

// AccountResponse

// .flow.access.Account account = 1;
inline bool AccountResponse::_internal_has_account() const {
  return this != internal_default_instance() && account_ != nullptr;
}
inline bool AccountResponse::has_account() const {
  return _internal_has_account();
}
inline void AccountResponse::clear_account() {
  if (GetArenaForAllocation() == nullptr && account_ != nullptr) {
    delete account_;
  }
  account_ = nullptr;
}
inline const ::flow::access::Account& AccountResponse::_internal_account() const {
  const ::flow::access::Account* p = account_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Account&>(
      ::flow::access::_Account_default_instance_);
}
inline const ::flow::access::Account& AccountResponse::account() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountResponse.account)
  return _internal_account();
}
inline void AccountResponse::unsafe_arena_set_allocated_account(
    ::flow::access::Account* account) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(account_);
  }
  account_ = account;
  if (account) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.AccountResponse.account)
}
inline ::flow::access::Account* AccountResponse::release_account() {
  
  ::flow::access::Account* temp = account_;
  account_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Account* AccountResponse::unsafe_arena_release_account() {
  // @@protoc_insertion_point(field_release:flow.access.AccountResponse.account)
  
  ::flow::access::Account* temp = account_;
  account_ = nullptr;
  return temp;
}
inline ::flow::access::Account* AccountResponse::_internal_mutable_account() {
  
  if (account_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Account>(GetArenaForAllocation());
    account_ = p;
  }
  return account_;
}
inline ::flow::access::Account* AccountResponse::mutable_account() {
  ::flow::access::Account* _msg = _internal_mutable_account();
  // @@protoc_insertion_point(field_mutable:flow.access.AccountResponse.account)
  return _msg;
}
inline void AccountResponse::set_allocated_account(::flow::access::Account* account) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete account_;
  }
  if (account) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Account>::GetOwningArena(account);
    if (message_arena != submessage_arena) {
      account = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    
  } else {
    
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:flow.access.AccountResponse.account)
}

// -------------------------------------------------------------------

// GetAccountAtLatestBlockRequest

// bytes address = 1;
inline void GetAccountAtLatestBlockRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountAtLatestBlockRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtLatestBlockRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtLatestBlockRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtLatestBlockRequest.address)
}
inline std::string* GetAccountAtLatestBlockRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountAtLatestBlockRequest.address)
  return _s;
}
inline const std::string& GetAccountAtLatestBlockRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountAtLatestBlockRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtLatestBlockRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtLatestBlockRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountAtLatestBlockRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtLatestBlockRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountAtLatestBlockRequest.address)
}

// -------------------------------------------------------------------

// GetAccountAtBlockHeightRequest

// bytes address = 1;
inline void GetAccountAtBlockHeightRequest::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& GetAccountAtBlockHeightRequest::address() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtBlockHeightRequest.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetAccountAtBlockHeightRequest::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtBlockHeightRequest.address)
}
inline std::string* GetAccountAtBlockHeightRequest::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.GetAccountAtBlockHeightRequest.address)
  return _s;
}
inline const std::string& GetAccountAtBlockHeightRequest::_internal_address() const {
  return address_.Get();
}
inline void GetAccountAtBlockHeightRequest::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockHeightRequest::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetAccountAtBlockHeightRequest::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.GetAccountAtBlockHeightRequest.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetAccountAtBlockHeightRequest::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetAccountAtBlockHeightRequest.address)
}

// uint64 block_height = 2;
inline void GetAccountAtBlockHeightRequest::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAccountAtBlockHeightRequest::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetAccountAtBlockHeightRequest::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetAccountAtBlockHeightRequest.block_height)
  return _internal_block_height();
}
inline void GetAccountAtBlockHeightRequest::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void GetAccountAtBlockHeightRequest::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetAccountAtBlockHeightRequest.block_height)
}

// -------------------------------------------------------------------

// ExecuteScriptResponse

// bytes value = 1;
inline void ExecuteScriptResponse::clear_value() {
  value_.ClearToEmpty();
}
inline const std::string& ExecuteScriptResponse::value() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptResponse.value)
  return _internal_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptResponse::set_value(ArgT0&& arg0, ArgT... args) {
 
 value_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptResponse.value)
}
inline std::string* ExecuteScriptResponse::mutable_value() {
  std::string* _s = _internal_mutable_value();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptResponse.value)
  return _s;
}
inline const std::string& ExecuteScriptResponse::_internal_value() const {
  return value_.Get();
}
inline void ExecuteScriptResponse::_internal_set_value(const std::string& value) {
  
  value_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptResponse::_internal_mutable_value() {
  
  return value_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptResponse::release_value() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptResponse.value)
  return value_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptResponse::set_allocated_value(std::string* value) {
  if (value != nullptr) {
    
  } else {
    
  }
  value_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), value,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptResponse.value)
}

// -------------------------------------------------------------------

// ExecuteScriptAtLatestBlockRequest

// bytes script = 1;
inline void ExecuteScriptAtLatestBlockRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtLatestBlockRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtLatestBlockRequest.script)
}
inline std::string* ExecuteScriptAtLatestBlockRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtLatestBlockRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtLatestBlockRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtLatestBlockRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtLatestBlockRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtLatestBlockRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtLatestBlockRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtLatestBlockRequest.script)
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockIdRequest

// bytes block_id = 1;
inline void ExecuteScriptAtBlockIdRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIdRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockIdRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIdRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIdRequest.block_id)
}
inline std::string* ExecuteScriptAtBlockIdRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockIdRequest.block_id)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIdRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void ExecuteScriptAtBlockIdRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIdRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIdRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockIdRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIdRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockIdRequest.block_id)
}

// bytes script = 2;
inline void ExecuteScriptAtBlockIdRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockIdRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockIdRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockIdRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockIdRequest.script)
}
inline std::string* ExecuteScriptAtBlockIdRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockIdRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockIdRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtBlockIdRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIdRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockIdRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockIdRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockIdRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockIdRequest.script)
}

// -------------------------------------------------------------------

// ExecuteScriptAtBlockHeightRequest

// uint64 block_height = 1;
inline void ExecuteScriptAtBlockHeightRequest::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExecuteScriptAtBlockHeightRequest::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 ExecuteScriptAtBlockHeightRequest::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockHeightRequest.block_height)
  return _internal_block_height();
}
inline void ExecuteScriptAtBlockHeightRequest::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void ExecuteScriptAtBlockHeightRequest::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.block_height)
}

// bytes script = 2;
inline void ExecuteScriptAtBlockHeightRequest::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::script() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecuteScriptAtBlockHeightRequest::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecuteScriptAtBlockHeightRequest.script)
}
inline std::string* ExecuteScriptAtBlockHeightRequest::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return _s;
}
inline const std::string& ExecuteScriptAtBlockHeightRequest::_internal_script() const {
  return script_.Get();
}
inline void ExecuteScriptAtBlockHeightRequest::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockHeightRequest::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecuteScriptAtBlockHeightRequest::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.ExecuteScriptAtBlockHeightRequest.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecuteScriptAtBlockHeightRequest::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecuteScriptAtBlockHeightRequest.script)
}

// -------------------------------------------------------------------

// EventsResponse_Result

// bytes block_id = 1;
inline void EventsResponse_Result::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& EventsResponse_Result::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void EventsResponse_Result::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.EventsResponse.Result.block_id)
}
inline std::string* EventsResponse_Result::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.block_id)
  return _s;
}
inline const std::string& EventsResponse_Result::_internal_block_id() const {
  return block_id_.Get();
}
inline void EventsResponse_Result::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* EventsResponse_Result::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* EventsResponse_Result::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.EventsResponse.Result.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void EventsResponse_Result::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.EventsResponse.Result.block_id)
}

// uint64 block_height = 2;
inline void EventsResponse_Result::clear_block_height() {
  block_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EventsResponse_Result::_internal_block_height() const {
  return block_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 EventsResponse_Result::block_height() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_height)
  return _internal_block_height();
}
inline void EventsResponse_Result::_internal_set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  block_height_ = value;
}
inline void EventsResponse_Result::set_block_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_block_height(value);
  // @@protoc_insertion_point(field_set:flow.access.EventsResponse.Result.block_height)
}

// repeated .flow.access.Event events = 3;
inline int EventsResponse_Result::_internal_events_size() const {
  return events_.size();
}
inline int EventsResponse_Result::events_size() const {
  return _internal_events_size();
}
inline void EventsResponse_Result::clear_events() {
  events_.Clear();
}
inline ::flow::access::Event* EventsResponse_Result::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.events)
  return events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >*
EventsResponse_Result::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.EventsResponse.Result.events)
  return &events_;
}
inline const ::flow::access::Event& EventsResponse_Result::_internal_events(int index) const {
  return events_.Get(index);
}
inline const ::flow::access::Event& EventsResponse_Result::events(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.events)
  return _internal_events(index);
}
inline ::flow::access::Event* EventsResponse_Result::_internal_add_events() {
  return events_.Add();
}
inline ::flow::access::Event* EventsResponse_Result::add_events() {
  ::flow::access::Event* _add = _internal_add_events();
  // @@protoc_insertion_point(field_add:flow.access.EventsResponse.Result.events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Event >&
EventsResponse_Result::events() const {
  // @@protoc_insertion_point(field_list:flow.access.EventsResponse.Result.events)
  return events_;
}

// .flow.access.Timestamp block_timestamp = 4;
inline bool EventsResponse_Result::_internal_has_block_timestamp() const {
  return this != internal_default_instance() && block_timestamp_ != nullptr;
}
inline bool EventsResponse_Result::has_block_timestamp() const {
  return _internal_has_block_timestamp();
}
inline void EventsResponse_Result::clear_block_timestamp() {
  if (GetArenaForAllocation() == nullptr && block_timestamp_ != nullptr) {
    delete block_timestamp_;
  }
  block_timestamp_ = nullptr;
}
inline const ::flow::access::Timestamp& EventsResponse_Result::_internal_block_timestamp() const {
  const ::flow::access::Timestamp* p = block_timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Timestamp&>(
      ::flow::access::_Timestamp_default_instance_);
}
inline const ::flow::access::Timestamp& EventsResponse_Result::block_timestamp() const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.Result.block_timestamp)
  return _internal_block_timestamp();
}
inline void EventsResponse_Result::unsafe_arena_set_allocated_block_timestamp(
    ::flow::access::Timestamp* block_timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(block_timestamp_);
  }
  block_timestamp_ = block_timestamp;
  if (block_timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.EventsResponse.Result.block_timestamp)
}
inline ::flow::access::Timestamp* EventsResponse_Result::release_block_timestamp() {
  
  ::flow::access::Timestamp* temp = block_timestamp_;
  block_timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Timestamp* EventsResponse_Result::unsafe_arena_release_block_timestamp() {
  // @@protoc_insertion_point(field_release:flow.access.EventsResponse.Result.block_timestamp)
  
  ::flow::access::Timestamp* temp = block_timestamp_;
  block_timestamp_ = nullptr;
  return temp;
}
inline ::flow::access::Timestamp* EventsResponse_Result::_internal_mutable_block_timestamp() {
  
  if (block_timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Timestamp>(GetArenaForAllocation());
    block_timestamp_ = p;
  }
  return block_timestamp_;
}
inline ::flow::access::Timestamp* EventsResponse_Result::mutable_block_timestamp() {
  ::flow::access::Timestamp* _msg = _internal_mutable_block_timestamp();
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.Result.block_timestamp)
  return _msg;
}
inline void EventsResponse_Result::set_allocated_block_timestamp(::flow::access::Timestamp* block_timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete block_timestamp_;
  }
  if (block_timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Timestamp>::GetOwningArena(block_timestamp);
    if (message_arena != submessage_arena) {
      block_timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, block_timestamp, submessage_arena);
    }
    
  } else {
    
  }
  block_timestamp_ = block_timestamp;
  // @@protoc_insertion_point(field_set_allocated:flow.access.EventsResponse.Result.block_timestamp)
}

// -------------------------------------------------------------------

// EventsResponse

// repeated .flow.access.EventsResponse.Result results = 1;
inline int EventsResponse::_internal_results_size() const {
  return results_.size();
}
inline int EventsResponse::results_size() const {
  return _internal_results_size();
}
inline void EventsResponse::clear_results() {
  results_.Clear();
}
inline ::flow::access::EventsResponse_Result* EventsResponse::mutable_results(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.EventsResponse.results)
  return results_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >*
EventsResponse::mutable_results() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.EventsResponse.results)
  return &results_;
}
inline const ::flow::access::EventsResponse_Result& EventsResponse::_internal_results(int index) const {
  return results_.Get(index);
}
inline const ::flow::access::EventsResponse_Result& EventsResponse::results(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.EventsResponse.results)
  return _internal_results(index);
}
inline ::flow::access::EventsResponse_Result* EventsResponse::_internal_add_results() {
  return results_.Add();
}
inline ::flow::access::EventsResponse_Result* EventsResponse::add_results() {
  ::flow::access::EventsResponse_Result* _add = _internal_add_results();
  // @@protoc_insertion_point(field_add:flow.access.EventsResponse.results)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::EventsResponse_Result >&
EventsResponse::results() const {
  // @@protoc_insertion_point(field_list:flow.access.EventsResponse.results)
  return results_;
}

// -------------------------------------------------------------------

// GetEventsForHeightRangeRequest

// string type = 1;
inline void GetEventsForHeightRangeRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetEventsForHeightRangeRequest::type() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForHeightRangeRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.type)
}
inline std::string* GetEventsForHeightRangeRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForHeightRangeRequest.type)
  return _s;
}
inline const std::string& GetEventsForHeightRangeRequest::_internal_type() const {
  return type_.Get();
}
inline void GetEventsForHeightRangeRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForHeightRangeRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForHeightRangeRequest::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.GetEventsForHeightRangeRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForHeightRangeRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetEventsForHeightRangeRequest.type)
}

// uint64 start_height = 2;
inline void GetEventsForHeightRangeRequest::clear_start_height() {
  start_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::_internal_start_height() const {
  return start_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::start_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.start_height)
  return _internal_start_height();
}
inline void GetEventsForHeightRangeRequest::_internal_set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  start_height_ = value;
}
inline void GetEventsForHeightRangeRequest::set_start_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_start_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.start_height)
}

// uint64 end_height = 3;
inline void GetEventsForHeightRangeRequest::clear_end_height() {
  end_height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::_internal_end_height() const {
  return end_height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 GetEventsForHeightRangeRequest::end_height() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForHeightRangeRequest.end_height)
  return _internal_end_height();
}
inline void GetEventsForHeightRangeRequest::_internal_set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  end_height_ = value;
}
inline void GetEventsForHeightRangeRequest::set_end_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_end_height(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForHeightRangeRequest.end_height)
}

// -------------------------------------------------------------------

// GetEventsForBlockIdsRequest

// string type = 1;
inline void GetEventsForBlockIdsRequest::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& GetEventsForBlockIdsRequest::type() const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForBlockIdsRequest.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetEventsForBlockIdsRequest::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIdsRequest.type)
}
inline std::string* GetEventsForBlockIdsRequest::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForBlockIdsRequest.type)
  return _s;
}
inline const std::string& GetEventsForBlockIdsRequest::_internal_type() const {
  return type_.Get();
}
inline void GetEventsForBlockIdsRequest::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIdsRequest::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetEventsForBlockIdsRequest::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.GetEventsForBlockIdsRequest.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetEventsForBlockIdsRequest::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetEventsForBlockIdsRequest.type)
}

// repeated bytes block_ids = 2;
inline int GetEventsForBlockIdsRequest::_internal_block_ids_size() const {
  return block_ids_.size();
}
inline int GetEventsForBlockIdsRequest::block_ids_size() const {
  return _internal_block_ids_size();
}
inline void GetEventsForBlockIdsRequest::clear_block_ids() {
  block_ids_.Clear();
}
inline std::string* GetEventsForBlockIdsRequest::add_block_ids() {
  std::string* _s = _internal_add_block_ids();
  // @@protoc_insertion_point(field_add_mutable:flow.access.GetEventsForBlockIdsRequest.block_ids)
  return _s;
}
inline const std::string& GetEventsForBlockIdsRequest::_internal_block_ids(int index) const {
  return block_ids_.Get(index);
}
inline const std::string& GetEventsForBlockIdsRequest::block_ids(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.GetEventsForBlockIdsRequest.block_ids)
  return _internal_block_ids(index);
}
inline std::string* GetEventsForBlockIdsRequest::mutable_block_ids(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.GetEventsForBlockIdsRequest.block_ids)
  return block_ids_.Mutable(index);
}
inline void GetEventsForBlockIdsRequest::set_block_ids(int index, const std::string& value) {
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::set_block_ids(int index, std::string&& value) {
  block_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::set_block_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::set_block_ids(int index, const void* value, size_t size) {
  block_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline std::string* GetEventsForBlockIdsRequest::_internal_add_block_ids() {
  return block_ids_.Add();
}
inline void GetEventsForBlockIdsRequest::add_block_ids(const std::string& value) {
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::add_block_ids(std::string&& value) {
  block_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::add_block_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  block_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline void GetEventsForBlockIdsRequest::add_block_ids(const void* value, size_t size) {
  block_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.GetEventsForBlockIdsRequest.block_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
GetEventsForBlockIdsRequest::block_ids() const {
  // @@protoc_insertion_point(field_list:flow.access.GetEventsForBlockIdsRequest.block_ids)
  return block_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
GetEventsForBlockIdsRequest::mutable_block_ids() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.GetEventsForBlockIdsRequest.block_ids)
  return &block_ids_;
}

// -------------------------------------------------------------------

// GetNetworkParametersResponse

// string chain_id = 1;
inline void GetNetworkParametersResponse::clear_chain_id() {
  chain_id_.ClearToEmpty();
}
inline const std::string& GetNetworkParametersResponse::chain_id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetNetworkParametersResponse.chain_id)
  return _internal_chain_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetNetworkParametersResponse::set_chain_id(ArgT0&& arg0, ArgT... args) {
 
 chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetNetworkParametersResponse.chain_id)
}
inline std::string* GetNetworkParametersResponse::mutable_chain_id() {
  std::string* _s = _internal_mutable_chain_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetNetworkParametersResponse.chain_id)
  return _s;
}
inline const std::string& GetNetworkParametersResponse::_internal_chain_id() const {
  return chain_id_.Get();
}
inline void GetNetworkParametersResponse::_internal_set_chain_id(const std::string& value) {
  
  chain_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetNetworkParametersResponse::_internal_mutable_chain_id() {
  
  return chain_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetNetworkParametersResponse::release_chain_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetNetworkParametersResponse.chain_id)
  return chain_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetNetworkParametersResponse::set_allocated_chain_id(std::string* chain_id) {
  if (chain_id != nullptr) {
    
  } else {
    
  }
  chain_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), chain_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetNetworkParametersResponse.chain_id)
}

// -------------------------------------------------------------------

// GetNetworkParametersRequest

// -------------------------------------------------------------------

// ProtocolStateSnapshotResponse

// bytes serializedSnapshot = 1;
inline void ProtocolStateSnapshotResponse::clear_serializedsnapshot() {
  serializedsnapshot_.ClearToEmpty();
}
inline const std::string& ProtocolStateSnapshotResponse::serializedsnapshot() const {
  // @@protoc_insertion_point(field_get:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return _internal_serializedsnapshot();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ProtocolStateSnapshotResponse::set_serializedsnapshot(ArgT0&& arg0, ArgT... args) {
 
 serializedsnapshot_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
}
inline std::string* ProtocolStateSnapshotResponse::mutable_serializedsnapshot() {
  std::string* _s = _internal_mutable_serializedsnapshot();
  // @@protoc_insertion_point(field_mutable:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return _s;
}
inline const std::string& ProtocolStateSnapshotResponse::_internal_serializedsnapshot() const {
  return serializedsnapshot_.Get();
}
inline void ProtocolStateSnapshotResponse::_internal_set_serializedsnapshot(const std::string& value) {
  
  serializedsnapshot_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ProtocolStateSnapshotResponse::_internal_mutable_serializedsnapshot() {
  
  return serializedsnapshot_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ProtocolStateSnapshotResponse::release_serializedsnapshot() {
  // @@protoc_insertion_point(field_release:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
  return serializedsnapshot_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ProtocolStateSnapshotResponse::set_allocated_serializedsnapshot(std::string* serializedsnapshot) {
  if (serializedsnapshot != nullptr) {
    
  } else {
    
  }
  serializedsnapshot_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), serializedsnapshot,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ProtocolStateSnapshotResponse.serializedSnapshot)
}

// -------------------------------------------------------------------

// GetLatestProtocolStateSnapshotRequest

// -------------------------------------------------------------------

// ExecutionResultForBlockIdResponse

// .flow.access.ExecutionResult execution_result = 1;
inline bool ExecutionResultForBlockIdResponse::_internal_has_execution_result() const {
  return this != internal_default_instance() && execution_result_ != nullptr;
}
inline bool ExecutionResultForBlockIdResponse::has_execution_result() const {
  return _internal_has_execution_result();
}
inline void ExecutionResultForBlockIdResponse::clear_execution_result() {
  if (GetArenaForAllocation() == nullptr && execution_result_ != nullptr) {
    delete execution_result_;
  }
  execution_result_ = nullptr;
}
inline const ::flow::access::ExecutionResult& ExecutionResultForBlockIdResponse::_internal_execution_result() const {
  const ::flow::access::ExecutionResult* p = execution_result_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::ExecutionResult&>(
      ::flow::access::_ExecutionResult_default_instance_);
}
inline const ::flow::access::ExecutionResult& ExecutionResultForBlockIdResponse::execution_result() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResultForBlockIdResponse.execution_result)
  return _internal_execution_result();
}
inline void ExecutionResultForBlockIdResponse::unsafe_arena_set_allocated_execution_result(
    ::flow::access::ExecutionResult* execution_result) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(execution_result_);
  }
  execution_result_ = execution_result;
  if (execution_result) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.ExecutionResultForBlockIdResponse.execution_result)
}
inline ::flow::access::ExecutionResult* ExecutionResultForBlockIdResponse::release_execution_result() {
  
  ::flow::access::ExecutionResult* temp = execution_result_;
  execution_result_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::ExecutionResult* ExecutionResultForBlockIdResponse::unsafe_arena_release_execution_result() {
  // @@protoc_insertion_point(field_release:flow.access.ExecutionResultForBlockIdResponse.execution_result)
  
  ::flow::access::ExecutionResult* temp = execution_result_;
  execution_result_ = nullptr;
  return temp;
}
inline ::flow::access::ExecutionResult* ExecutionResultForBlockIdResponse::_internal_mutable_execution_result() {
  
  if (execution_result_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::ExecutionResult>(GetArenaForAllocation());
    execution_result_ = p;
  }
  return execution_result_;
}
inline ::flow::access::ExecutionResult* ExecutionResultForBlockIdResponse::mutable_execution_result() {
  ::flow::access::ExecutionResult* _msg = _internal_mutable_execution_result();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResultForBlockIdResponse.execution_result)
  return _msg;
}
inline void ExecutionResultForBlockIdResponse::set_allocated_execution_result(::flow::access::ExecutionResult* execution_result) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete execution_result_;
  }
  if (execution_result) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::ExecutionResult>::GetOwningArena(execution_result);
    if (message_arena != submessage_arena) {
      execution_result = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, execution_result, submessage_arena);
    }
    
  } else {
    
  }
  execution_result_ = execution_result;
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecutionResultForBlockIdResponse.execution_result)
}

// -------------------------------------------------------------------

// GetExecutionResultForBlockIdRequest

// bytes block_id = 1;
inline void GetExecutionResultForBlockIdRequest::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& GetExecutionResultForBlockIdRequest::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.GetExecutionResultForBlockIdRequest.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void GetExecutionResultForBlockIdRequest::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.GetExecutionResultForBlockIdRequest.block_id)
}
inline std::string* GetExecutionResultForBlockIdRequest::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.GetExecutionResultForBlockIdRequest.block_id)
  return _s;
}
inline const std::string& GetExecutionResultForBlockIdRequest::_internal_block_id() const {
  return block_id_.Get();
}
inline void GetExecutionResultForBlockIdRequest::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* GetExecutionResultForBlockIdRequest::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* GetExecutionResultForBlockIdRequest::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.GetExecutionResultForBlockIdRequest.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void GetExecutionResultForBlockIdRequest::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.GetExecutionResultForBlockIdRequest.block_id)
}

// -------------------------------------------------------------------

// Block

// bytes id = 1;
inline void Block::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Block::id() const {
  // @@protoc_insertion_point(field_get:flow.access.Block.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Block.id)
}
inline std::string* Block::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Block.id)
  return _s;
}
inline const std::string& Block::_internal_id() const {
  return id_.Get();
}
inline void Block::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.Block.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Block.id)
}

// bytes parent_id = 2;
inline void Block::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& Block::parent_id() const {
  // @@protoc_insertion_point(field_get:flow.access.Block.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Block::set_parent_id(ArgT0&& arg0, ArgT... args) {
 
 parent_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Block.parent_id)
}
inline std::string* Block::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Block.parent_id)
  return _s;
}
inline const std::string& Block::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void Block::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Block::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Block::release_parent_id() {
  // @@protoc_insertion_point(field_release:flow.access.Block.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Block::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Block.parent_id)
}

// uint64 height = 3;
inline void Block::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Block::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Block::height() const {
  // @@protoc_insertion_point(field_get:flow.access.Block.height)
  return _internal_height();
}
inline void Block::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void Block::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.Block.height)
}

// .flow.access.Timestamp timestamp = 4;
inline bool Block::_internal_has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != nullptr;
}
inline bool Block::has_timestamp() const {
  return _internal_has_timestamp();
}
inline void Block::clear_timestamp() {
  if (GetArenaForAllocation() == nullptr && timestamp_ != nullptr) {
    delete timestamp_;
  }
  timestamp_ = nullptr;
}
inline const ::flow::access::Timestamp& Block::_internal_timestamp() const {
  const ::flow::access::Timestamp* p = timestamp_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::Timestamp&>(
      ::flow::access::_Timestamp_default_instance_);
}
inline const ::flow::access::Timestamp& Block::timestamp() const {
  // @@protoc_insertion_point(field_get:flow.access.Block.timestamp)
  return _internal_timestamp();
}
inline void Block::unsafe_arena_set_allocated_timestamp(
    ::flow::access::Timestamp* timestamp) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(timestamp_);
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.Block.timestamp)
}
inline ::flow::access::Timestamp* Block::release_timestamp() {
  
  ::flow::access::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::Timestamp* Block::unsafe_arena_release_timestamp() {
  // @@protoc_insertion_point(field_release:flow.access.Block.timestamp)
  
  ::flow::access::Timestamp* temp = timestamp_;
  timestamp_ = nullptr;
  return temp;
}
inline ::flow::access::Timestamp* Block::_internal_mutable_timestamp() {
  
  if (timestamp_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::Timestamp>(GetArenaForAllocation());
    timestamp_ = p;
  }
  return timestamp_;
}
inline ::flow::access::Timestamp* Block::mutable_timestamp() {
  ::flow::access::Timestamp* _msg = _internal_mutable_timestamp();
  // @@protoc_insertion_point(field_mutable:flow.access.Block.timestamp)
  return _msg;
}
inline void Block::set_allocated_timestamp(::flow::access::Timestamp* timestamp) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete timestamp_;
  }
  if (timestamp) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::Timestamp>::GetOwningArena(timestamp);
    if (message_arena != submessage_arena) {
      timestamp = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, timestamp, submessage_arena);
    }
    
  } else {
    
  }
  timestamp_ = timestamp;
  // @@protoc_insertion_point(field_set_allocated:flow.access.Block.timestamp)
}

// repeated .flow.access.CollectionGuarantee collection_guarantees = 5;
inline int Block::_internal_collection_guarantees_size() const {
  return collection_guarantees_.size();
}
inline int Block::collection_guarantees_size() const {
  return _internal_collection_guarantees_size();
}
inline void Block::clear_collection_guarantees() {
  collection_guarantees_.Clear();
}
inline ::flow::access::CollectionGuarantee* Block::mutable_collection_guarantees(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Block.collection_guarantees)
  return collection_guarantees_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::CollectionGuarantee >*
Block::mutable_collection_guarantees() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Block.collection_guarantees)
  return &collection_guarantees_;
}
inline const ::flow::access::CollectionGuarantee& Block::_internal_collection_guarantees(int index) const {
  return collection_guarantees_.Get(index);
}
inline const ::flow::access::CollectionGuarantee& Block::collection_guarantees(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Block.collection_guarantees)
  return _internal_collection_guarantees(index);
}
inline ::flow::access::CollectionGuarantee* Block::_internal_add_collection_guarantees() {
  return collection_guarantees_.Add();
}
inline ::flow::access::CollectionGuarantee* Block::add_collection_guarantees() {
  ::flow::access::CollectionGuarantee* _add = _internal_add_collection_guarantees();
  // @@protoc_insertion_point(field_add:flow.access.Block.collection_guarantees)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::CollectionGuarantee >&
Block::collection_guarantees() const {
  // @@protoc_insertion_point(field_list:flow.access.Block.collection_guarantees)
  return collection_guarantees_;
}

// repeated .flow.access.BlockSeal block_seals = 6;
inline int Block::_internal_block_seals_size() const {
  return block_seals_.size();
}
inline int Block::block_seals_size() const {
  return _internal_block_seals_size();
}
inline void Block::clear_block_seals() {
  block_seals_.Clear();
}
inline ::flow::access::BlockSeal* Block::mutable_block_seals(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Block.block_seals)
  return block_seals_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::BlockSeal >*
Block::mutable_block_seals() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Block.block_seals)
  return &block_seals_;
}
inline const ::flow::access::BlockSeal& Block::_internal_block_seals(int index) const {
  return block_seals_.Get(index);
}
inline const ::flow::access::BlockSeal& Block::block_seals(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Block.block_seals)
  return _internal_block_seals(index);
}
inline ::flow::access::BlockSeal* Block::_internal_add_block_seals() {
  return block_seals_.Add();
}
inline ::flow::access::BlockSeal* Block::add_block_seals() {
  ::flow::access::BlockSeal* _add = _internal_add_block_seals();
  // @@protoc_insertion_point(field_add:flow.access.Block.block_seals)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::BlockSeal >&
Block::block_seals() const {
  // @@protoc_insertion_point(field_list:flow.access.Block.block_seals)
  return block_seals_;
}

// repeated bytes signatures = 7;
inline int Block::_internal_signatures_size() const {
  return signatures_.size();
}
inline int Block::signatures_size() const {
  return _internal_signatures_size();
}
inline void Block::clear_signatures() {
  signatures_.Clear();
}
inline std::string* Block::add_signatures() {
  std::string* _s = _internal_add_signatures();
  // @@protoc_insertion_point(field_add_mutable:flow.access.Block.signatures)
  return _s;
}
inline const std::string& Block::_internal_signatures(int index) const {
  return signatures_.Get(index);
}
inline const std::string& Block::signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Block.signatures)
  return _internal_signatures(index);
}
inline std::string* Block::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Block.signatures)
  return signatures_.Mutable(index);
}
inline void Block::set_signatures(int index, const std::string& value) {
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.Block.signatures)
}
inline void Block::set_signatures(int index, std::string&& value) {
  signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.Block.signatures)
}
inline void Block::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.Block.signatures)
}
inline void Block::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.Block.signatures)
}
inline std::string* Block::_internal_add_signatures() {
  return signatures_.Add();
}
inline void Block::add_signatures(const std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.Block.signatures)
}
inline void Block::add_signatures(std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.Block.signatures)
}
inline void Block::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.Block.signatures)
}
inline void Block::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.Block.signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Block::signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.Block.signatures)
  return signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Block::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Block.signatures)
  return &signatures_;
}

// -------------------------------------------------------------------

// BlockHeader

// bytes id = 1;
inline void BlockHeader::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& BlockHeader::id() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockHeader.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.BlockHeader.id)
}
inline std::string* BlockHeader::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockHeader.id)
  return _s;
}
inline const std::string& BlockHeader::_internal_id() const {
  return id_.Get();
}
inline void BlockHeader::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.BlockHeader.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockHeader.id)
}

// bytes parent_id = 2;
inline void BlockHeader::clear_parent_id() {
  parent_id_.ClearToEmpty();
}
inline const std::string& BlockHeader::parent_id() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockHeader.parent_id)
  return _internal_parent_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockHeader::set_parent_id(ArgT0&& arg0, ArgT... args) {
 
 parent_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.BlockHeader.parent_id)
}
inline std::string* BlockHeader::mutable_parent_id() {
  std::string* _s = _internal_mutable_parent_id();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockHeader.parent_id)
  return _s;
}
inline const std::string& BlockHeader::_internal_parent_id() const {
  return parent_id_.Get();
}
inline void BlockHeader::_internal_set_parent_id(const std::string& value) {
  
  parent_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockHeader::_internal_mutable_parent_id() {
  
  return parent_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockHeader::release_parent_id() {
  // @@protoc_insertion_point(field_release:flow.access.BlockHeader.parent_id)
  return parent_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockHeader::set_allocated_parent_id(std::string* parent_id) {
  if (parent_id != nullptr) {
    
  } else {
    
  }
  parent_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), parent_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockHeader.parent_id)
}

// uint64 height = 3;
inline void BlockHeader::clear_height() {
  height_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::_internal_height() const {
  return height_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 BlockHeader::height() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockHeader.height)
  return _internal_height();
}
inline void BlockHeader::_internal_set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  height_ = value;
}
inline void BlockHeader::set_height(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_height(value);
  // @@protoc_insertion_point(field_set:flow.access.BlockHeader.height)
}

// -------------------------------------------------------------------

// BlockSeal

// bytes block_id = 1;
inline void BlockSeal::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& BlockSeal::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockSeal.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockSeal::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.block_id)
}
inline std::string* BlockSeal::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockSeal.block_id)
  return _s;
}
inline const std::string& BlockSeal::_internal_block_id() const {
  return block_id_.Get();
}
inline void BlockSeal::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockSeal::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockSeal::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.BlockSeal.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockSeal::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockSeal.block_id)
}

// bytes execution_receipt_id = 2;
inline void BlockSeal::clear_execution_receipt_id() {
  execution_receipt_id_.ClearToEmpty();
}
inline const std::string& BlockSeal::execution_receipt_id() const {
  // @@protoc_insertion_point(field_get:flow.access.BlockSeal.execution_receipt_id)
  return _internal_execution_receipt_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void BlockSeal::set_execution_receipt_id(ArgT0&& arg0, ArgT... args) {
 
 execution_receipt_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.execution_receipt_id)
}
inline std::string* BlockSeal::mutable_execution_receipt_id() {
  std::string* _s = _internal_mutable_execution_receipt_id();
  // @@protoc_insertion_point(field_mutable:flow.access.BlockSeal.execution_receipt_id)
  return _s;
}
inline const std::string& BlockSeal::_internal_execution_receipt_id() const {
  return execution_receipt_id_.Get();
}
inline void BlockSeal::_internal_set_execution_receipt_id(const std::string& value) {
  
  execution_receipt_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* BlockSeal::_internal_mutable_execution_receipt_id() {
  
  return execution_receipt_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* BlockSeal::release_execution_receipt_id() {
  // @@protoc_insertion_point(field_release:flow.access.BlockSeal.execution_receipt_id)
  return execution_receipt_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void BlockSeal::set_allocated_execution_receipt_id(std::string* execution_receipt_id) {
  if (execution_receipt_id != nullptr) {
    
  } else {
    
  }
  execution_receipt_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), execution_receipt_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.BlockSeal.execution_receipt_id)
}

// repeated bytes execution_receipt_signatures = 3;
inline int BlockSeal::_internal_execution_receipt_signatures_size() const {
  return execution_receipt_signatures_.size();
}
inline int BlockSeal::execution_receipt_signatures_size() const {
  return _internal_execution_receipt_signatures_size();
}
inline void BlockSeal::clear_execution_receipt_signatures() {
  execution_receipt_signatures_.Clear();
}
inline std::string* BlockSeal::add_execution_receipt_signatures() {
  std::string* _s = _internal_add_execution_receipt_signatures();
  // @@protoc_insertion_point(field_add_mutable:flow.access.BlockSeal.execution_receipt_signatures)
  return _s;
}
inline const std::string& BlockSeal::_internal_execution_receipt_signatures(int index) const {
  return execution_receipt_signatures_.Get(index);
}
inline const std::string& BlockSeal::execution_receipt_signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.BlockSeal.execution_receipt_signatures)
  return _internal_execution_receipt_signatures(index);
}
inline std::string* BlockSeal::mutable_execution_receipt_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.BlockSeal.execution_receipt_signatures)
  return execution_receipt_signatures_.Mutable(index);
}
inline void BlockSeal::set_execution_receipt_signatures(int index, const std::string& value) {
  execution_receipt_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::set_execution_receipt_signatures(int index, std::string&& value) {
  execution_receipt_signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::set_execution_receipt_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  execution_receipt_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::set_execution_receipt_signatures(int index, const void* value, size_t size) {
  execution_receipt_signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.BlockSeal.execution_receipt_signatures)
}
inline std::string* BlockSeal::_internal_add_execution_receipt_signatures() {
  return execution_receipt_signatures_.Add();
}
inline void BlockSeal::add_execution_receipt_signatures(const std::string& value) {
  execution_receipt_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::add_execution_receipt_signatures(std::string&& value) {
  execution_receipt_signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::add_execution_receipt_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  execution_receipt_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.BlockSeal.execution_receipt_signatures)
}
inline void BlockSeal::add_execution_receipt_signatures(const void* value, size_t size) {
  execution_receipt_signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.BlockSeal.execution_receipt_signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockSeal::execution_receipt_signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.BlockSeal.execution_receipt_signatures)
  return execution_receipt_signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockSeal::mutable_execution_receipt_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.BlockSeal.execution_receipt_signatures)
  return &execution_receipt_signatures_;
}

// repeated bytes result_approval_signatures = 4;
inline int BlockSeal::_internal_result_approval_signatures_size() const {
  return result_approval_signatures_.size();
}
inline int BlockSeal::result_approval_signatures_size() const {
  return _internal_result_approval_signatures_size();
}
inline void BlockSeal::clear_result_approval_signatures() {
  result_approval_signatures_.Clear();
}
inline std::string* BlockSeal::add_result_approval_signatures() {
  std::string* _s = _internal_add_result_approval_signatures();
  // @@protoc_insertion_point(field_add_mutable:flow.access.BlockSeal.result_approval_signatures)
  return _s;
}
inline const std::string& BlockSeal::_internal_result_approval_signatures(int index) const {
  return result_approval_signatures_.Get(index);
}
inline const std::string& BlockSeal::result_approval_signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.BlockSeal.result_approval_signatures)
  return _internal_result_approval_signatures(index);
}
inline std::string* BlockSeal::mutable_result_approval_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.BlockSeal.result_approval_signatures)
  return result_approval_signatures_.Mutable(index);
}
inline void BlockSeal::set_result_approval_signatures(int index, const std::string& value) {
  result_approval_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::set_result_approval_signatures(int index, std::string&& value) {
  result_approval_signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::set_result_approval_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  result_approval_signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::set_result_approval_signatures(int index, const void* value, size_t size) {
  result_approval_signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.BlockSeal.result_approval_signatures)
}
inline std::string* BlockSeal::_internal_add_result_approval_signatures() {
  return result_approval_signatures_.Add();
}
inline void BlockSeal::add_result_approval_signatures(const std::string& value) {
  result_approval_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::add_result_approval_signatures(std::string&& value) {
  result_approval_signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::add_result_approval_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  result_approval_signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.BlockSeal.result_approval_signatures)
}
inline void BlockSeal::add_result_approval_signatures(const void* value, size_t size) {
  result_approval_signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.BlockSeal.result_approval_signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
BlockSeal::result_approval_signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.BlockSeal.result_approval_signatures)
  return result_approval_signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
BlockSeal::mutable_result_approval_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.BlockSeal.result_approval_signatures)
  return &result_approval_signatures_;
}

// -------------------------------------------------------------------

// Collection

// bytes id = 1;
inline void Collection::clear_id() {
  id_.ClearToEmpty();
}
inline const std::string& Collection::id() const {
  // @@protoc_insertion_point(field_get:flow.access.Collection.id)
  return _internal_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Collection::set_id(ArgT0&& arg0, ArgT... args) {
 
 id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Collection.id)
}
inline std::string* Collection::mutable_id() {
  std::string* _s = _internal_mutable_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Collection.id)
  return _s;
}
inline const std::string& Collection::_internal_id() const {
  return id_.Get();
}
inline void Collection::_internal_set_id(const std::string& value) {
  
  id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Collection::_internal_mutable_id() {
  
  return id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Collection::release_id() {
  // @@protoc_insertion_point(field_release:flow.access.Collection.id)
  return id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Collection::set_allocated_id(std::string* id) {
  if (id != nullptr) {
    
  } else {
    
  }
  id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Collection.id)
}

// repeated bytes transaction_ids = 2;
inline int Collection::_internal_transaction_ids_size() const {
  return transaction_ids_.size();
}
inline int Collection::transaction_ids_size() const {
  return _internal_transaction_ids_size();
}
inline void Collection::clear_transaction_ids() {
  transaction_ids_.Clear();
}
inline std::string* Collection::add_transaction_ids() {
  std::string* _s = _internal_add_transaction_ids();
  // @@protoc_insertion_point(field_add_mutable:flow.access.Collection.transaction_ids)
  return _s;
}
inline const std::string& Collection::_internal_transaction_ids(int index) const {
  return transaction_ids_.Get(index);
}
inline const std::string& Collection::transaction_ids(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Collection.transaction_ids)
  return _internal_transaction_ids(index);
}
inline std::string* Collection::mutable_transaction_ids(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Collection.transaction_ids)
  return transaction_ids_.Mutable(index);
}
inline void Collection::set_transaction_ids(int index, const std::string& value) {
  transaction_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.Collection.transaction_ids)
}
inline void Collection::set_transaction_ids(int index, std::string&& value) {
  transaction_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.Collection.transaction_ids)
}
inline void Collection::set_transaction_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transaction_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.Collection.transaction_ids)
}
inline void Collection::set_transaction_ids(int index, const void* value, size_t size) {
  transaction_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.Collection.transaction_ids)
}
inline std::string* Collection::_internal_add_transaction_ids() {
  return transaction_ids_.Add();
}
inline void Collection::add_transaction_ids(const std::string& value) {
  transaction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.Collection.transaction_ids)
}
inline void Collection::add_transaction_ids(std::string&& value) {
  transaction_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.Collection.transaction_ids)
}
inline void Collection::add_transaction_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  transaction_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.Collection.transaction_ids)
}
inline void Collection::add_transaction_ids(const void* value, size_t size) {
  transaction_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.Collection.transaction_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Collection::transaction_ids() const {
  // @@protoc_insertion_point(field_list:flow.access.Collection.transaction_ids)
  return transaction_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Collection::mutable_transaction_ids() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Collection.transaction_ids)
  return &transaction_ids_;
}

// -------------------------------------------------------------------

// CollectionGuarantee

// bytes collection_id = 1;
inline void CollectionGuarantee::clear_collection_id() {
  collection_id_.ClearToEmpty();
}
inline const std::string& CollectionGuarantee::collection_id() const {
  // @@protoc_insertion_point(field_get:flow.access.CollectionGuarantee.collection_id)
  return _internal_collection_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void CollectionGuarantee::set_collection_id(ArgT0&& arg0, ArgT... args) {
 
 collection_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.CollectionGuarantee.collection_id)
}
inline std::string* CollectionGuarantee::mutable_collection_id() {
  std::string* _s = _internal_mutable_collection_id();
  // @@protoc_insertion_point(field_mutable:flow.access.CollectionGuarantee.collection_id)
  return _s;
}
inline const std::string& CollectionGuarantee::_internal_collection_id() const {
  return collection_id_.Get();
}
inline void CollectionGuarantee::_internal_set_collection_id(const std::string& value) {
  
  collection_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* CollectionGuarantee::_internal_mutable_collection_id() {
  
  return collection_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* CollectionGuarantee::release_collection_id() {
  // @@protoc_insertion_point(field_release:flow.access.CollectionGuarantee.collection_id)
  return collection_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void CollectionGuarantee::set_allocated_collection_id(std::string* collection_id) {
  if (collection_id != nullptr) {
    
  } else {
    
  }
  collection_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), collection_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.CollectionGuarantee.collection_id)
}

// repeated bytes signatures = 2;
inline int CollectionGuarantee::_internal_signatures_size() const {
  return signatures_.size();
}
inline int CollectionGuarantee::signatures_size() const {
  return _internal_signatures_size();
}
inline void CollectionGuarantee::clear_signatures() {
  signatures_.Clear();
}
inline std::string* CollectionGuarantee::add_signatures() {
  std::string* _s = _internal_add_signatures();
  // @@protoc_insertion_point(field_add_mutable:flow.access.CollectionGuarantee.signatures)
  return _s;
}
inline const std::string& CollectionGuarantee::_internal_signatures(int index) const {
  return signatures_.Get(index);
}
inline const std::string& CollectionGuarantee::signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.CollectionGuarantee.signatures)
  return _internal_signatures(index);
}
inline std::string* CollectionGuarantee::mutable_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.CollectionGuarantee.signatures)
  return signatures_.Mutable(index);
}
inline void CollectionGuarantee::set_signatures(int index, const std::string& value) {
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::set_signatures(int index, std::string&& value) {
  signatures_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::set_signatures(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::set_signatures(int index, const void* value, size_t size) {
  signatures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.CollectionGuarantee.signatures)
}
inline std::string* CollectionGuarantee::_internal_add_signatures() {
  return signatures_.Add();
}
inline void CollectionGuarantee::add_signatures(const std::string& value) {
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::add_signatures(std::string&& value) {
  signatures_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::add_signatures(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  signatures_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.CollectionGuarantee.signatures)
}
inline void CollectionGuarantee::add_signatures(const void* value, size_t size) {
  signatures_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.CollectionGuarantee.signatures)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
CollectionGuarantee::signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.CollectionGuarantee.signatures)
  return signatures_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
CollectionGuarantee::mutable_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.CollectionGuarantee.signatures)
  return &signatures_;
}

// -------------------------------------------------------------------

// Transaction

// bytes script = 1;
inline void Transaction::clear_script() {
  script_.ClearToEmpty();
}
inline const std::string& Transaction::script() const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.script)
  return _internal_script();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_script(ArgT0&& arg0, ArgT... args) {
 
 script_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Transaction.script)
}
inline std::string* Transaction::mutable_script() {
  std::string* _s = _internal_mutable_script();
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.script)
  return _s;
}
inline const std::string& Transaction::_internal_script() const {
  return script_.Get();
}
inline void Transaction::_internal_set_script(const std::string& value) {
  
  script_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_script() {
  
  return script_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction::release_script() {
  // @@protoc_insertion_point(field_release:flow.access.Transaction.script)
  return script_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction::set_allocated_script(std::string* script) {
  if (script != nullptr) {
    
  } else {
    
  }
  script_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), script,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Transaction.script)
}

// repeated bytes arguments = 2;
inline int Transaction::_internal_arguments_size() const {
  return arguments_.size();
}
inline int Transaction::arguments_size() const {
  return _internal_arguments_size();
}
inline void Transaction::clear_arguments() {
  arguments_.Clear();
}
inline std::string* Transaction::add_arguments() {
  std::string* _s = _internal_add_arguments();
  // @@protoc_insertion_point(field_add_mutable:flow.access.Transaction.arguments)
  return _s;
}
inline const std::string& Transaction::_internal_arguments(int index) const {
  return arguments_.Get(index);
}
inline const std::string& Transaction::arguments(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.arguments)
  return _internal_arguments(index);
}
inline std::string* Transaction::mutable_arguments(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.arguments)
  return arguments_.Mutable(index);
}
inline void Transaction::set_arguments(int index, const std::string& value) {
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.Transaction.arguments)
}
inline void Transaction::set_arguments(int index, std::string&& value) {
  arguments_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.Transaction.arguments)
}
inline void Transaction::set_arguments(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.Transaction.arguments)
}
inline void Transaction::set_arguments(int index, const void* value, size_t size) {
  arguments_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.Transaction.arguments)
}
inline std::string* Transaction::_internal_add_arguments() {
  return arguments_.Add();
}
inline void Transaction::add_arguments(const std::string& value) {
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.Transaction.arguments)
}
inline void Transaction::add_arguments(std::string&& value) {
  arguments_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.Transaction.arguments)
}
inline void Transaction::add_arguments(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  arguments_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.Transaction.arguments)
}
inline void Transaction::add_arguments(const void* value, size_t size) {
  arguments_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.Transaction.arguments)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Transaction::arguments() const {
  // @@protoc_insertion_point(field_list:flow.access.Transaction.arguments)
  return arguments_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Transaction::mutable_arguments() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Transaction.arguments)
  return &arguments_;
}

// bytes reference_block_id = 3;
inline void Transaction::clear_reference_block_id() {
  reference_block_id_.ClearToEmpty();
}
inline const std::string& Transaction::reference_block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.reference_block_id)
  return _internal_reference_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_reference_block_id(ArgT0&& arg0, ArgT... args) {
 
 reference_block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Transaction.reference_block_id)
}
inline std::string* Transaction::mutable_reference_block_id() {
  std::string* _s = _internal_mutable_reference_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.reference_block_id)
  return _s;
}
inline const std::string& Transaction::_internal_reference_block_id() const {
  return reference_block_id_.Get();
}
inline void Transaction::_internal_set_reference_block_id(const std::string& value) {
  
  reference_block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_reference_block_id() {
  
  return reference_block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction::release_reference_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.Transaction.reference_block_id)
  return reference_block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction::set_allocated_reference_block_id(std::string* reference_block_id) {
  if (reference_block_id != nullptr) {
    
  } else {
    
  }
  reference_block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), reference_block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Transaction.reference_block_id)
}

// uint64 gas_limit = 4;
inline void Transaction::clear_gas_limit() {
  gas_limit_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Transaction::_internal_gas_limit() const {
  return gas_limit_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Transaction::gas_limit() const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.gas_limit)
  return _internal_gas_limit();
}
inline void Transaction::_internal_set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  gas_limit_ = value;
}
inline void Transaction::set_gas_limit(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_gas_limit(value);
  // @@protoc_insertion_point(field_set:flow.access.Transaction.gas_limit)
}

// .flow.access.TransactionProposalKey proposal_key = 5;
inline bool Transaction::_internal_has_proposal_key() const {
  return this != internal_default_instance() && proposal_key_ != nullptr;
}
inline bool Transaction::has_proposal_key() const {
  return _internal_has_proposal_key();
}
inline void Transaction::clear_proposal_key() {
  if (GetArenaForAllocation() == nullptr && proposal_key_ != nullptr) {
    delete proposal_key_;
  }
  proposal_key_ = nullptr;
}
inline const ::flow::access::TransactionProposalKey& Transaction::_internal_proposal_key() const {
  const ::flow::access::TransactionProposalKey* p = proposal_key_;
  return p != nullptr ? *p : reinterpret_cast<const ::flow::access::TransactionProposalKey&>(
      ::flow::access::_TransactionProposalKey_default_instance_);
}
inline const ::flow::access::TransactionProposalKey& Transaction::proposal_key() const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.proposal_key)
  return _internal_proposal_key();
}
inline void Transaction::unsafe_arena_set_allocated_proposal_key(
    ::flow::access::TransactionProposalKey* proposal_key) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(proposal_key_);
  }
  proposal_key_ = proposal_key;
  if (proposal_key) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:flow.access.Transaction.proposal_key)
}
inline ::flow::access::TransactionProposalKey* Transaction::release_proposal_key() {
  
  ::flow::access::TransactionProposalKey* temp = proposal_key_;
  proposal_key_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::flow::access::TransactionProposalKey* Transaction::unsafe_arena_release_proposal_key() {
  // @@protoc_insertion_point(field_release:flow.access.Transaction.proposal_key)
  
  ::flow::access::TransactionProposalKey* temp = proposal_key_;
  proposal_key_ = nullptr;
  return temp;
}
inline ::flow::access::TransactionProposalKey* Transaction::_internal_mutable_proposal_key() {
  
  if (proposal_key_ == nullptr) {
    auto* p = CreateMaybeMessage<::flow::access::TransactionProposalKey>(GetArenaForAllocation());
    proposal_key_ = p;
  }
  return proposal_key_;
}
inline ::flow::access::TransactionProposalKey* Transaction::mutable_proposal_key() {
  ::flow::access::TransactionProposalKey* _msg = _internal_mutable_proposal_key();
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.proposal_key)
  return _msg;
}
inline void Transaction::set_allocated_proposal_key(::flow::access::TransactionProposalKey* proposal_key) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete proposal_key_;
  }
  if (proposal_key) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper<::flow::access::TransactionProposalKey>::GetOwningArena(proposal_key);
    if (message_arena != submessage_arena) {
      proposal_key = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, proposal_key, submessage_arena);
    }
    
  } else {
    
  }
  proposal_key_ = proposal_key;
  // @@protoc_insertion_point(field_set_allocated:flow.access.Transaction.proposal_key)
}

// bytes payer = 6;
inline void Transaction::clear_payer() {
  payer_.ClearToEmpty();
}
inline const std::string& Transaction::payer() const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.payer)
  return _internal_payer();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Transaction::set_payer(ArgT0&& arg0, ArgT... args) {
 
 payer_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Transaction.payer)
}
inline std::string* Transaction::mutable_payer() {
  std::string* _s = _internal_mutable_payer();
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.payer)
  return _s;
}
inline const std::string& Transaction::_internal_payer() const {
  return payer_.Get();
}
inline void Transaction::_internal_set_payer(const std::string& value) {
  
  payer_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Transaction::_internal_mutable_payer() {
  
  return payer_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Transaction::release_payer() {
  // @@protoc_insertion_point(field_release:flow.access.Transaction.payer)
  return payer_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Transaction::set_allocated_payer(std::string* payer) {
  if (payer != nullptr) {
    
  } else {
    
  }
  payer_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payer,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Transaction.payer)
}

// repeated bytes authorizers = 7;
inline int Transaction::_internal_authorizers_size() const {
  return authorizers_.size();
}
inline int Transaction::authorizers_size() const {
  return _internal_authorizers_size();
}
inline void Transaction::clear_authorizers() {
  authorizers_.Clear();
}
inline std::string* Transaction::add_authorizers() {
  std::string* _s = _internal_add_authorizers();
  // @@protoc_insertion_point(field_add_mutable:flow.access.Transaction.authorizers)
  return _s;
}
inline const std::string& Transaction::_internal_authorizers(int index) const {
  return authorizers_.Get(index);
}
inline const std::string& Transaction::authorizers(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.authorizers)
  return _internal_authorizers(index);
}
inline std::string* Transaction::mutable_authorizers(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.authorizers)
  return authorizers_.Mutable(index);
}
inline void Transaction::set_authorizers(int index, const std::string& value) {
  authorizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:flow.access.Transaction.authorizers)
}
inline void Transaction::set_authorizers(int index, std::string&& value) {
  authorizers_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:flow.access.Transaction.authorizers)
}
inline void Transaction::set_authorizers(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  authorizers_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:flow.access.Transaction.authorizers)
}
inline void Transaction::set_authorizers(int index, const void* value, size_t size) {
  authorizers_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:flow.access.Transaction.authorizers)
}
inline std::string* Transaction::_internal_add_authorizers() {
  return authorizers_.Add();
}
inline void Transaction::add_authorizers(const std::string& value) {
  authorizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:flow.access.Transaction.authorizers)
}
inline void Transaction::add_authorizers(std::string&& value) {
  authorizers_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:flow.access.Transaction.authorizers)
}
inline void Transaction::add_authorizers(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  authorizers_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:flow.access.Transaction.authorizers)
}
inline void Transaction::add_authorizers(const void* value, size_t size) {
  authorizers_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:flow.access.Transaction.authorizers)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
Transaction::authorizers() const {
  // @@protoc_insertion_point(field_list:flow.access.Transaction.authorizers)
  return authorizers_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
Transaction::mutable_authorizers() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Transaction.authorizers)
  return &authorizers_;
}

// repeated .flow.access.TransactionSignature payload_signatures = 8;
inline int Transaction::_internal_payload_signatures_size() const {
  return payload_signatures_.size();
}
inline int Transaction::payload_signatures_size() const {
  return _internal_payload_signatures_size();
}
inline void Transaction::clear_payload_signatures() {
  payload_signatures_.Clear();
}
inline ::flow::access::TransactionSignature* Transaction::mutable_payload_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.payload_signatures)
  return payload_signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >*
Transaction::mutable_payload_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Transaction.payload_signatures)
  return &payload_signatures_;
}
inline const ::flow::access::TransactionSignature& Transaction::_internal_payload_signatures(int index) const {
  return payload_signatures_.Get(index);
}
inline const ::flow::access::TransactionSignature& Transaction::payload_signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.payload_signatures)
  return _internal_payload_signatures(index);
}
inline ::flow::access::TransactionSignature* Transaction::_internal_add_payload_signatures() {
  return payload_signatures_.Add();
}
inline ::flow::access::TransactionSignature* Transaction::add_payload_signatures() {
  ::flow::access::TransactionSignature* _add = _internal_add_payload_signatures();
  // @@protoc_insertion_point(field_add:flow.access.Transaction.payload_signatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >&
Transaction::payload_signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.Transaction.payload_signatures)
  return payload_signatures_;
}

// repeated .flow.access.TransactionSignature envelope_signatures = 9;
inline int Transaction::_internal_envelope_signatures_size() const {
  return envelope_signatures_.size();
}
inline int Transaction::envelope_signatures_size() const {
  return _internal_envelope_signatures_size();
}
inline void Transaction::clear_envelope_signatures() {
  envelope_signatures_.Clear();
}
inline ::flow::access::TransactionSignature* Transaction::mutable_envelope_signatures(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Transaction.envelope_signatures)
  return envelope_signatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >*
Transaction::mutable_envelope_signatures() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Transaction.envelope_signatures)
  return &envelope_signatures_;
}
inline const ::flow::access::TransactionSignature& Transaction::_internal_envelope_signatures(int index) const {
  return envelope_signatures_.Get(index);
}
inline const ::flow::access::TransactionSignature& Transaction::envelope_signatures(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Transaction.envelope_signatures)
  return _internal_envelope_signatures(index);
}
inline ::flow::access::TransactionSignature* Transaction::_internal_add_envelope_signatures() {
  return envelope_signatures_.Add();
}
inline ::flow::access::TransactionSignature* Transaction::add_envelope_signatures() {
  ::flow::access::TransactionSignature* _add = _internal_add_envelope_signatures();
  // @@protoc_insertion_point(field_add:flow.access.Transaction.envelope_signatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::TransactionSignature >&
Transaction::envelope_signatures() const {
  // @@protoc_insertion_point(field_list:flow.access.Transaction.envelope_signatures)
  return envelope_signatures_;
}

// -------------------------------------------------------------------

// TransactionProposalKey

// bytes address = 1;
inline void TransactionProposalKey::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& TransactionProposalKey::address() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionProposalKey.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionProposalKey::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionProposalKey.address)
}
inline std::string* TransactionProposalKey::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionProposalKey.address)
  return _s;
}
inline const std::string& TransactionProposalKey::_internal_address() const {
  return address_.Get();
}
inline void TransactionProposalKey::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionProposalKey::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionProposalKey::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionProposalKey.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionProposalKey::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionProposalKey.address)
}

// uint32 key_id = 2;
inline void TransactionProposalKey::clear_key_id() {
  key_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionProposalKey::_internal_key_id() const {
  return key_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionProposalKey::key_id() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionProposalKey.key_id)
  return _internal_key_id();
}
inline void TransactionProposalKey::_internal_set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  key_id_ = value;
}
inline void TransactionProposalKey::set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_id(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionProposalKey.key_id)
}

// uint64 sequence_number = 3;
inline void TransactionProposalKey::clear_sequence_number() {
  sequence_number_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransactionProposalKey::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 TransactionProposalKey::sequence_number() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionProposalKey.sequence_number)
  return _internal_sequence_number();
}
inline void TransactionProposalKey::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  sequence_number_ = value;
}
inline void TransactionProposalKey::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionProposalKey.sequence_number)
}

// -------------------------------------------------------------------

// TransactionSignature

// bytes address = 1;
inline void TransactionSignature::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& TransactionSignature::address() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionSignature.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionSignature::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionSignature.address)
}
inline std::string* TransactionSignature::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionSignature.address)
  return _s;
}
inline const std::string& TransactionSignature::_internal_address() const {
  return address_.Get();
}
inline void TransactionSignature::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionSignature::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionSignature::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionSignature.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionSignature::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionSignature.address)
}

// uint32 key_id = 2;
inline void TransactionSignature::clear_key_id() {
  key_id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionSignature::_internal_key_id() const {
  return key_id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 TransactionSignature::key_id() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionSignature.key_id)
  return _internal_key_id();
}
inline void TransactionSignature::_internal_set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  key_id_ = value;
}
inline void TransactionSignature::set_key_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_key_id(value);
  // @@protoc_insertion_point(field_set:flow.access.TransactionSignature.key_id)
}

// bytes signature = 3;
inline void TransactionSignature::clear_signature() {
  signature_.ClearToEmpty();
}
inline const std::string& TransactionSignature::signature() const {
  // @@protoc_insertion_point(field_get:flow.access.TransactionSignature.signature)
  return _internal_signature();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void TransactionSignature::set_signature(ArgT0&& arg0, ArgT... args) {
 
 signature_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.TransactionSignature.signature)
}
inline std::string* TransactionSignature::mutable_signature() {
  std::string* _s = _internal_mutable_signature();
  // @@protoc_insertion_point(field_mutable:flow.access.TransactionSignature.signature)
  return _s;
}
inline const std::string& TransactionSignature::_internal_signature() const {
  return signature_.Get();
}
inline void TransactionSignature::_internal_set_signature(const std::string& value) {
  
  signature_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* TransactionSignature::_internal_mutable_signature() {
  
  return signature_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* TransactionSignature::release_signature() {
  // @@protoc_insertion_point(field_release:flow.access.TransactionSignature.signature)
  return signature_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void TransactionSignature::set_allocated_signature(std::string* signature) {
  if (signature != nullptr) {
    
  } else {
    
  }
  signature_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), signature,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.TransactionSignature.signature)
}

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// Account

// bytes address = 1;
inline void Account::clear_address() {
  address_.ClearToEmpty();
}
inline const std::string& Account::address() const {
  // @@protoc_insertion_point(field_get:flow.access.Account.address)
  return _internal_address();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_address(ArgT0&& arg0, ArgT... args) {
 
 address_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Account.address)
}
inline std::string* Account::mutable_address() {
  std::string* _s = _internal_mutable_address();
  // @@protoc_insertion_point(field_mutable:flow.access.Account.address)
  return _s;
}
inline const std::string& Account::_internal_address() const {
  return address_.Get();
}
inline void Account::_internal_set_address(const std::string& value) {
  
  address_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_address() {
  
  return address_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_address() {
  // @@protoc_insertion_point(field_release:flow.access.Account.address)
  return address_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_address(std::string* address) {
  if (address != nullptr) {
    
  } else {
    
  }
  address_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), address,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Account.address)
}

// uint64 balance = 2;
inline void Account::clear_balance() {
  balance_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Account::_internal_balance() const {
  return balance_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Account::balance() const {
  // @@protoc_insertion_point(field_get:flow.access.Account.balance)
  return _internal_balance();
}
inline void Account::_internal_set_balance(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  balance_ = value;
}
inline void Account::set_balance(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_balance(value);
  // @@protoc_insertion_point(field_set:flow.access.Account.balance)
}

// bytes code = 3;
inline void Account::clear_code() {
  code_.ClearToEmpty();
}
inline const std::string& Account::code() const {
  // @@protoc_insertion_point(field_get:flow.access.Account.code)
  return _internal_code();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Account::set_code(ArgT0&& arg0, ArgT... args) {
 
 code_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Account.code)
}
inline std::string* Account::mutable_code() {
  std::string* _s = _internal_mutable_code();
  // @@protoc_insertion_point(field_mutable:flow.access.Account.code)
  return _s;
}
inline const std::string& Account::_internal_code() const {
  return code_.Get();
}
inline void Account::_internal_set_code(const std::string& value) {
  
  code_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Account::_internal_mutable_code() {
  
  return code_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Account::release_code() {
  // @@protoc_insertion_point(field_release:flow.access.Account.code)
  return code_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Account::set_allocated_code(std::string* code) {
  if (code != nullptr) {
    
  } else {
    
  }
  code_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), code,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Account.code)
}

// repeated .flow.access.AccountKey keys = 4;
inline int Account::_internal_keys_size() const {
  return keys_.size();
}
inline int Account::keys_size() const {
  return _internal_keys_size();
}
inline void Account::clear_keys() {
  keys_.Clear();
}
inline ::flow::access::AccountKey* Account::mutable_keys(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.Account.keys)
  return keys_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::AccountKey >*
Account::mutable_keys() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.Account.keys)
  return &keys_;
}
inline const ::flow::access::AccountKey& Account::_internal_keys(int index) const {
  return keys_.Get(index);
}
inline const ::flow::access::AccountKey& Account::keys(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.Account.keys)
  return _internal_keys(index);
}
inline ::flow::access::AccountKey* Account::_internal_add_keys() {
  return keys_.Add();
}
inline ::flow::access::AccountKey* Account::add_keys() {
  ::flow::access::AccountKey* _add = _internal_add_keys();
  // @@protoc_insertion_point(field_add:flow.access.Account.keys)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::AccountKey >&
Account::keys() const {
  // @@protoc_insertion_point(field_list:flow.access.Account.keys)
  return keys_;
}

// map<string, bytes> contracts = 5;
inline int Account::_internal_contracts_size() const {
  return contracts_.size();
}
inline int Account::contracts_size() const {
  return _internal_contracts_size();
}
inline void Account::clear_contracts() {
  contracts_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Account::_internal_contracts() const {
  return contracts_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
Account::contracts() const {
  // @@protoc_insertion_point(field_map:flow.access.Account.contracts)
  return _internal_contracts();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Account::_internal_mutable_contracts() {
  return contracts_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
Account::mutable_contracts() {
  // @@protoc_insertion_point(field_mutable_map:flow.access.Account.contracts)
  return _internal_mutable_contracts();
}

// -------------------------------------------------------------------

// AccountKey

// uint32 id = 1;
inline void AccountKey::clear_id() {
  id_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::_internal_id() const {
  return id_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::id() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.id)
  return _internal_id();
}
inline void AccountKey::_internal_set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  id_ = value;
}
inline void AccountKey::set_id(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.id)
}

// bytes public_key = 2;
inline void AccountKey::clear_public_key() {
  public_key_.ClearToEmpty();
}
inline const std::string& AccountKey::public_key() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.public_key)
  return _internal_public_key();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void AccountKey::set_public_key(ArgT0&& arg0, ArgT... args) {
 
 public_key_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.public_key)
}
inline std::string* AccountKey::mutable_public_key() {
  std::string* _s = _internal_mutable_public_key();
  // @@protoc_insertion_point(field_mutable:flow.access.AccountKey.public_key)
  return _s;
}
inline const std::string& AccountKey::_internal_public_key() const {
  return public_key_.Get();
}
inline void AccountKey::_internal_set_public_key(const std::string& value) {
  
  public_key_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* AccountKey::_internal_mutable_public_key() {
  
  return public_key_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* AccountKey::release_public_key() {
  // @@protoc_insertion_point(field_release:flow.access.AccountKey.public_key)
  return public_key_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void AccountKey::set_allocated_public_key(std::string* public_key) {
  if (public_key != nullptr) {
    
  } else {
    
  }
  public_key_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), public_key,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.AccountKey.public_key)
}

// uint32 sign_algo = 3;
inline void AccountKey::clear_sign_algo() {
  sign_algo_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::_internal_sign_algo() const {
  return sign_algo_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::sign_algo() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.sign_algo)
  return _internal_sign_algo();
}
inline void AccountKey::_internal_set_sign_algo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sign_algo_ = value;
}
inline void AccountKey::set_sign_algo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sign_algo(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.sign_algo)
}

// uint32 hash_algo = 4;
inline void AccountKey::clear_hash_algo() {
  hash_algo_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::_internal_hash_algo() const {
  return hash_algo_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::hash_algo() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.hash_algo)
  return _internal_hash_algo();
}
inline void AccountKey::_internal_set_hash_algo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  hash_algo_ = value;
}
inline void AccountKey::set_hash_algo(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_hash_algo(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.hash_algo)
}

// uint32 weight = 5;
inline void AccountKey::clear_weight() {
  weight_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::_internal_weight() const {
  return weight_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::weight() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.weight)
  return _internal_weight();
}
inline void AccountKey::_internal_set_weight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  weight_ = value;
}
inline void AccountKey::set_weight(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_weight(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.weight)
}

// uint32 sequence_number = 6;
inline void AccountKey::clear_sequence_number() {
  sequence_number_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::_internal_sequence_number() const {
  return sequence_number_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 AccountKey::sequence_number() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.sequence_number)
  return _internal_sequence_number();
}
inline void AccountKey::_internal_set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  sequence_number_ = value;
}
inline void AccountKey::set_sequence_number(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_sequence_number(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.sequence_number)
}

// bool revoked = 7;
inline void AccountKey::clear_revoked() {
  revoked_ = false;
}
inline bool AccountKey::_internal_revoked() const {
  return revoked_;
}
inline bool AccountKey::revoked() const {
  // @@protoc_insertion_point(field_get:flow.access.AccountKey.revoked)
  return _internal_revoked();
}
inline void AccountKey::_internal_set_revoked(bool value) {
  
  revoked_ = value;
}
inline void AccountKey::set_revoked(bool value) {
  _internal_set_revoked(value);
  // @@protoc_insertion_point(field_set:flow.access.AccountKey.revoked)
}

// -------------------------------------------------------------------

// Event

// string type = 1;
inline void Event::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& Event::type() const {
  // @@protoc_insertion_point(field_get:flow.access.Event.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Event.type)
}
inline std::string* Event::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.Event.type)
  return _s;
}
inline const std::string& Event::_internal_type() const {
  return type_.Get();
}
inline void Event::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.Event.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Event.type)
}

// bytes transaction_id = 2;
inline void Event::clear_transaction_id() {
  transaction_id_.ClearToEmpty();
}
inline const std::string& Event::transaction_id() const {
  // @@protoc_insertion_point(field_get:flow.access.Event.transaction_id)
  return _internal_transaction_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_transaction_id(ArgT0&& arg0, ArgT... args) {
 
 transaction_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Event.transaction_id)
}
inline std::string* Event::mutable_transaction_id() {
  std::string* _s = _internal_mutable_transaction_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Event.transaction_id)
  return _s;
}
inline const std::string& Event::_internal_transaction_id() const {
  return transaction_id_.Get();
}
inline void Event::_internal_set_transaction_id(const std::string& value) {
  
  transaction_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_transaction_id() {
  
  return transaction_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_transaction_id() {
  // @@protoc_insertion_point(field_release:flow.access.Event.transaction_id)
  return transaction_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_transaction_id(std::string* transaction_id) {
  if (transaction_id != nullptr) {
    
  } else {
    
  }
  transaction_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), transaction_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Event.transaction_id)
}

// uint32 transaction_index = 3;
inline void Event::clear_transaction_index() {
  transaction_index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Event::_internal_transaction_index() const {
  return transaction_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Event::transaction_index() const {
  // @@protoc_insertion_point(field_get:flow.access.Event.transaction_index)
  return _internal_transaction_index();
}
inline void Event::_internal_set_transaction_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  transaction_index_ = value;
}
inline void Event::set_transaction_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_transaction_index(value);
  // @@protoc_insertion_point(field_set:flow.access.Event.transaction_index)
}

// uint32 event_index = 4;
inline void Event::clear_event_index() {
  event_index_ = 0u;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Event::_internal_event_index() const {
  return event_index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint32 Event::event_index() const {
  // @@protoc_insertion_point(field_get:flow.access.Event.event_index)
  return _internal_event_index();
}
inline void Event::_internal_set_event_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  
  event_index_ = value;
}
inline void Event::set_event_index(::PROTOBUF_NAMESPACE_ID::uint32 value) {
  _internal_set_event_index(value);
  // @@protoc_insertion_point(field_set:flow.access.Event.event_index)
}

// bytes payload = 5;
inline void Event::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& Event::payload() const {
  // @@protoc_insertion_point(field_get:flow.access.Event.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Event::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Event.payload)
}
inline std::string* Event::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:flow.access.Event.payload)
  return _s;
}
inline const std::string& Event::_internal_payload() const {
  return payload_.Get();
}
inline void Event::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Event::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Event::release_payload() {
  // @@protoc_insertion_point(field_release:flow.access.Event.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Event::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Event.payload)
}

// -------------------------------------------------------------------

// ExecutionResult

// bytes previous_result_id = 1;
inline void ExecutionResult::clear_previous_result_id() {
  previous_result_id_.ClearToEmpty();
}
inline const std::string& ExecutionResult::previous_result_id() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResult.previous_result_id)
  return _internal_previous_result_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionResult::set_previous_result_id(ArgT0&& arg0, ArgT... args) {
 
 previous_result_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecutionResult.previous_result_id)
}
inline std::string* ExecutionResult::mutable_previous_result_id() {
  std::string* _s = _internal_mutable_previous_result_id();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResult.previous_result_id)
  return _s;
}
inline const std::string& ExecutionResult::_internal_previous_result_id() const {
  return previous_result_id_.Get();
}
inline void ExecutionResult::_internal_set_previous_result_id(const std::string& value) {
  
  previous_result_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionResult::_internal_mutable_previous_result_id() {
  
  return previous_result_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionResult::release_previous_result_id() {
  // @@protoc_insertion_point(field_release:flow.access.ExecutionResult.previous_result_id)
  return previous_result_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionResult::set_allocated_previous_result_id(std::string* previous_result_id) {
  if (previous_result_id != nullptr) {
    
  } else {
    
  }
  previous_result_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), previous_result_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecutionResult.previous_result_id)
}

// bytes block_id = 2;
inline void ExecutionResult::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& ExecutionResult::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResult.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ExecutionResult::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ExecutionResult.block_id)
}
inline std::string* ExecutionResult::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResult.block_id)
  return _s;
}
inline const std::string& ExecutionResult::_internal_block_id() const {
  return block_id_.Get();
}
inline void ExecutionResult::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ExecutionResult::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ExecutionResult::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.ExecutionResult.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ExecutionResult::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ExecutionResult.block_id)
}

// repeated .flow.access.Chunk chunks = 3;
inline int ExecutionResult::_internal_chunks_size() const {
  return chunks_.size();
}
inline int ExecutionResult::chunks_size() const {
  return _internal_chunks_size();
}
inline void ExecutionResult::clear_chunks() {
  chunks_.Clear();
}
inline ::flow::access::Chunk* ExecutionResult::mutable_chunks(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResult.chunks)
  return chunks_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Chunk >*
ExecutionResult::mutable_chunks() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.ExecutionResult.chunks)
  return &chunks_;
}
inline const ::flow::access::Chunk& ExecutionResult::_internal_chunks(int index) const {
  return chunks_.Get(index);
}
inline const ::flow::access::Chunk& ExecutionResult::chunks(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResult.chunks)
  return _internal_chunks(index);
}
inline ::flow::access::Chunk* ExecutionResult::_internal_add_chunks() {
  return chunks_.Add();
}
inline ::flow::access::Chunk* ExecutionResult::add_chunks() {
  ::flow::access::Chunk* _add = _internal_add_chunks();
  // @@protoc_insertion_point(field_add:flow.access.ExecutionResult.chunks)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::Chunk >&
ExecutionResult::chunks() const {
  // @@protoc_insertion_point(field_list:flow.access.ExecutionResult.chunks)
  return chunks_;
}

// repeated .flow.access.ServiceEvent service_events = 4;
inline int ExecutionResult::_internal_service_events_size() const {
  return service_events_.size();
}
inline int ExecutionResult::service_events_size() const {
  return _internal_service_events_size();
}
inline void ExecutionResult::clear_service_events() {
  service_events_.Clear();
}
inline ::flow::access::ServiceEvent* ExecutionResult::mutable_service_events(int index) {
  // @@protoc_insertion_point(field_mutable:flow.access.ExecutionResult.service_events)
  return service_events_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::ServiceEvent >*
ExecutionResult::mutable_service_events() {
  // @@protoc_insertion_point(field_mutable_list:flow.access.ExecutionResult.service_events)
  return &service_events_;
}
inline const ::flow::access::ServiceEvent& ExecutionResult::_internal_service_events(int index) const {
  return service_events_.Get(index);
}
inline const ::flow::access::ServiceEvent& ExecutionResult::service_events(int index) const {
  // @@protoc_insertion_point(field_get:flow.access.ExecutionResult.service_events)
  return _internal_service_events(index);
}
inline ::flow::access::ServiceEvent* ExecutionResult::_internal_add_service_events() {
  return service_events_.Add();
}
inline ::flow::access::ServiceEvent* ExecutionResult::add_service_events() {
  ::flow::access::ServiceEvent* _add = _internal_add_service_events();
  // @@protoc_insertion_point(field_add:flow.access.ExecutionResult.service_events)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::flow::access::ServiceEvent >&
ExecutionResult::service_events() const {
  // @@protoc_insertion_point(field_list:flow.access.ExecutionResult.service_events)
  return service_events_;
}

// -------------------------------------------------------------------

// Chunk

// bytes start_state = 1;
inline void Chunk::clear_start_state() {
  start_state_.ClearToEmpty();
}
inline const std::string& Chunk::start_state() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.start_state)
  return _internal_start_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chunk::set_start_state(ArgT0&& arg0, ArgT... args) {
 
 start_state_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Chunk.start_state)
}
inline std::string* Chunk::mutable_start_state() {
  std::string* _s = _internal_mutable_start_state();
  // @@protoc_insertion_point(field_mutable:flow.access.Chunk.start_state)
  return _s;
}
inline const std::string& Chunk::_internal_start_state() const {
  return start_state_.Get();
}
inline void Chunk::_internal_set_start_state(const std::string& value) {
  
  start_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chunk::_internal_mutable_start_state() {
  
  return start_state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chunk::release_start_state() {
  // @@protoc_insertion_point(field_release:flow.access.Chunk.start_state)
  return start_state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chunk::set_allocated_start_state(std::string* start_state) {
  if (start_state != nullptr) {
    
  } else {
    
  }
  start_state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), start_state,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Chunk.start_state)
}

// bytes event_collection = 2;
inline void Chunk::clear_event_collection() {
  event_collection_.ClearToEmpty();
}
inline const std::string& Chunk::event_collection() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.event_collection)
  return _internal_event_collection();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chunk::set_event_collection(ArgT0&& arg0, ArgT... args) {
 
 event_collection_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Chunk.event_collection)
}
inline std::string* Chunk::mutable_event_collection() {
  std::string* _s = _internal_mutable_event_collection();
  // @@protoc_insertion_point(field_mutable:flow.access.Chunk.event_collection)
  return _s;
}
inline const std::string& Chunk::_internal_event_collection() const {
  return event_collection_.Get();
}
inline void Chunk::_internal_set_event_collection(const std::string& value) {
  
  event_collection_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chunk::_internal_mutable_event_collection() {
  
  return event_collection_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chunk::release_event_collection() {
  // @@protoc_insertion_point(field_release:flow.access.Chunk.event_collection)
  return event_collection_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chunk::set_allocated_event_collection(std::string* event_collection) {
  if (event_collection != nullptr) {
    
  } else {
    
  }
  event_collection_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), event_collection,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Chunk.event_collection)
}

// bytes block_id = 3;
inline void Chunk::clear_block_id() {
  block_id_.ClearToEmpty();
}
inline const std::string& Chunk::block_id() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.block_id)
  return _internal_block_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chunk::set_block_id(ArgT0&& arg0, ArgT... args) {
 
 block_id_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Chunk.block_id)
}
inline std::string* Chunk::mutable_block_id() {
  std::string* _s = _internal_mutable_block_id();
  // @@protoc_insertion_point(field_mutable:flow.access.Chunk.block_id)
  return _s;
}
inline const std::string& Chunk::_internal_block_id() const {
  return block_id_.Get();
}
inline void Chunk::_internal_set_block_id(const std::string& value) {
  
  block_id_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chunk::_internal_mutable_block_id() {
  
  return block_id_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chunk::release_block_id() {
  // @@protoc_insertion_point(field_release:flow.access.Chunk.block_id)
  return block_id_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chunk::set_allocated_block_id(std::string* block_id) {
  if (block_id != nullptr) {
    
  } else {
    
  }
  block_id_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), block_id,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Chunk.block_id)
}

// uint64 total_computation_used = 4;
inline void Chunk::clear_total_computation_used() {
  total_computation_used_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::_internal_total_computation_used() const {
  return total_computation_used_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::total_computation_used() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.total_computation_used)
  return _internal_total_computation_used();
}
inline void Chunk::_internal_set_total_computation_used(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  total_computation_used_ = value;
}
inline void Chunk::set_total_computation_used(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_total_computation_used(value);
  // @@protoc_insertion_point(field_set:flow.access.Chunk.total_computation_used)
}

// uint64 number_of_transactions = 5;
inline void Chunk::clear_number_of_transactions() {
  number_of_transactions_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::_internal_number_of_transactions() const {
  return number_of_transactions_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::number_of_transactions() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.number_of_transactions)
  return _internal_number_of_transactions();
}
inline void Chunk::_internal_set_number_of_transactions(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  number_of_transactions_ = value;
}
inline void Chunk::set_number_of_transactions(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_number_of_transactions(value);
  // @@protoc_insertion_point(field_set:flow.access.Chunk.number_of_transactions)
}

// uint64 index = 6;
inline void Chunk::clear_index() {
  index_ = uint64_t{0u};
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::_internal_index() const {
  return index_;
}
inline ::PROTOBUF_NAMESPACE_ID::uint64 Chunk::index() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.index)
  return _internal_index();
}
inline void Chunk::_internal_set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  
  index_ = value;
}
inline void Chunk::set_index(::PROTOBUF_NAMESPACE_ID::uint64 value) {
  _internal_set_index(value);
  // @@protoc_insertion_point(field_set:flow.access.Chunk.index)
}

// bytes end_state = 7;
inline void Chunk::clear_end_state() {
  end_state_.ClearToEmpty();
}
inline const std::string& Chunk::end_state() const {
  // @@protoc_insertion_point(field_get:flow.access.Chunk.end_state)
  return _internal_end_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void Chunk::set_end_state(ArgT0&& arg0, ArgT... args) {
 
 end_state_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.Chunk.end_state)
}
inline std::string* Chunk::mutable_end_state() {
  std::string* _s = _internal_mutable_end_state();
  // @@protoc_insertion_point(field_mutable:flow.access.Chunk.end_state)
  return _s;
}
inline const std::string& Chunk::_internal_end_state() const {
  return end_state_.Get();
}
inline void Chunk::_internal_set_end_state(const std::string& value) {
  
  end_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* Chunk::_internal_mutable_end_state() {
  
  return end_state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* Chunk::release_end_state() {
  // @@protoc_insertion_point(field_release:flow.access.Chunk.end_state)
  return end_state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void Chunk::set_allocated_end_state(std::string* end_state) {
  if (end_state != nullptr) {
    
  } else {
    
  }
  end_state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), end_state,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.Chunk.end_state)
}

// -------------------------------------------------------------------

// ServiceEvent

// string type = 1;
inline void ServiceEvent::clear_type() {
  type_.ClearToEmpty();
}
inline const std::string& ServiceEvent::type() const {
  // @@protoc_insertion_point(field_get:flow.access.ServiceEvent.type)
  return _internal_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceEvent::set_type(ArgT0&& arg0, ArgT... args) {
 
 type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ServiceEvent.type)
}
inline std::string* ServiceEvent::mutable_type() {
  std::string* _s = _internal_mutable_type();
  // @@protoc_insertion_point(field_mutable:flow.access.ServiceEvent.type)
  return _s;
}
inline const std::string& ServiceEvent::_internal_type() const {
  return type_.Get();
}
inline void ServiceEvent::_internal_set_type(const std::string& value) {
  
  type_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceEvent::_internal_mutable_type() {
  
  return type_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceEvent::release_type() {
  // @@protoc_insertion_point(field_release:flow.access.ServiceEvent.type)
  return type_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceEvent::set_allocated_type(std::string* type) {
  if (type != nullptr) {
    
  } else {
    
  }
  type_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), type,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ServiceEvent.type)
}

// bytes payload = 2;
inline void ServiceEvent::clear_payload() {
  payload_.ClearToEmpty();
}
inline const std::string& ServiceEvent::payload() const {
  // @@protoc_insertion_point(field_get:flow.access.ServiceEvent.payload)
  return _internal_payload();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ServiceEvent::set_payload(ArgT0&& arg0, ArgT... args) {
 
 payload_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:flow.access.ServiceEvent.payload)
}
inline std::string* ServiceEvent::mutable_payload() {
  std::string* _s = _internal_mutable_payload();
  // @@protoc_insertion_point(field_mutable:flow.access.ServiceEvent.payload)
  return _s;
}
inline const std::string& ServiceEvent::_internal_payload() const {
  return payload_.Get();
}
inline void ServiceEvent::_internal_set_payload(const std::string& value) {
  
  payload_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* ServiceEvent::_internal_mutable_payload() {
  
  return payload_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* ServiceEvent::release_payload() {
  // @@protoc_insertion_point(field_release:flow.access.ServiceEvent.payload)
  return payload_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void ServiceEvent::set_allocated_payload(std::string* payload) {
  if (payload != nullptr) {
    
  } else {
    
  }
  payload_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), payload,
      GetArenaForAllocation());
  // @@protoc_insertion_point(field_set_allocated:flow.access.ServiceEvent.payload)
}

// -------------------------------------------------------------------

// Timestamp

// int64 seconds = 1;
inline void Timestamp::clear_seconds() {
  seconds_ = int64_t{0};
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::_internal_seconds() const {
  return seconds_;
}
inline ::PROTOBUF_NAMESPACE_ID::int64 Timestamp::seconds() const {
  // @@protoc_insertion_point(field_get:flow.access.Timestamp.seconds)
  return _internal_seconds();
}
inline void Timestamp::_internal_set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  
  seconds_ = value;
}
inline void Timestamp::set_seconds(::PROTOBUF_NAMESPACE_ID::int64 value) {
  _internal_set_seconds(value);
  // @@protoc_insertion_point(field_set:flow.access.Timestamp.seconds)
}

// int32 nanos = 2;
inline void Timestamp::clear_nanos() {
  nanos_ = 0;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Timestamp::_internal_nanos() const {
  return nanos_;
}
inline ::PROTOBUF_NAMESPACE_ID::int32 Timestamp::nanos() const {
  // @@protoc_insertion_point(field_get:flow.access.Timestamp.nanos)
  return _internal_nanos();
}
inline void Timestamp::_internal_set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  
  nanos_ = value;
}
inline void Timestamp::set_nanos(::PROTOBUF_NAMESPACE_ID::int32 value) {
  _internal_set_nanos(value);
  // @@protoc_insertion_point(field_set:flow.access.Timestamp.nanos)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace access
}  // namespace flow

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::flow::access::TransactionStatus> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::flow::access::TransactionStatus>() {
  return ::flow::access::TransactionStatus_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_flow_2eproto
