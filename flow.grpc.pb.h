// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: flow.proto
#ifndef GRPC_flow_2eproto__INCLUDED
#define GRPC_flow_2eproto__INCLUDED

#include "flow.pb.h"

#include <functional>
#include <grpc/impl/codegen/port_platform.h>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace flow {
namespace access {

class AccessAPI final {
 public:
  static constexpr char const* service_full_name() {
    return "flow.access.AccessAPI";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // *
    // The following is copied from https://docs.onflow.org/access-api/
    // You should also reference https://github.com/onflow/flow/blob/master/protobuf/flow/access/access.proto
    //
    virtual ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::flow::access::PingResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::flow::access::BlockHeaderResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetLatestBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetBlockByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByIDRaw(context, request, cq));
    }
    virtual ::grpc::Status GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::flow::access::BlockResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> AsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(AsyncGetBlockByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::flow::access::CollectionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>> AsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>>(AsyncGetCollectionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>> PrepareAsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>>(PrepareAsyncGetCollectionByIDRaw(context, request, cq));
    }
    virtual ::grpc::Status SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::flow::access::SendTransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>> AsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>>(AsyncSendTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>> PrepareAsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>>(PrepareAsyncSendTransactionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>> AsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>>(AsyncGetTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>> PrepareAsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>>(PrepareAsyncGetTransactionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResultResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::flow::access::AccountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> AsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(AsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::flow::access::AccountResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> AsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(AsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    virtual ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::flow::access::ExecuteScriptResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::flow::access::EventsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> AsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(AsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::flow::access::EventsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::flow::access::GetNetworkParametersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>> AsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>>(AsyncGetNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>> PrepareAsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>>(PrepareAsyncGetNetworkParametersRaw(context, request, cq));
    }
    virtual ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::flow::access::ProtocolStateSnapshotResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>> AsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>>(AsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>> PrepareAsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>>(PrepareAsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    virtual ::grpc::Status GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::flow::access::ExecutionResultForBlockIdResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>> AsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>>(AsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>> PrepareAsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>>(PrepareAsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // *
      // The following is copied from https://docs.onflow.org/access-api/
      // You should also reference https://github.com/onflow/flow/blob/master/protobuf/flow/access/access.proto
      //
      virtual void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
      virtual void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, std::function<void(::grpc::Status)>) = 0;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      virtual void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      #else
      virtual void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      #endif
    };
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    typedef class experimental_async_interface async_interface;
    #endif
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    async_interface* async() { return experimental_async(); }
    #endif
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* AsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>* AsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::CollectionResponse>* PrepareAsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>* AsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::SendTransactionResponse>* PrepareAsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>* AsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResponse>* PrepareAsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::TransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* AsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* AsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* AsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>* AsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::GetNetworkParametersResponse>* PrepareAsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>* AsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ProtocolStateSnapshotResponse>* PrepareAsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>* AsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::flow::access::ExecutionResultForBlockIdResponse>* PrepareAsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    ::grpc::Status Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::flow::access::PingResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>> AsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>>(AsyncPingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>> PrepareAsyncPing(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>>(PrepareAsyncPingRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetLatestBlockHeaderRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByIDRaw(context, request, cq));
    }
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::flow::access::BlockHeaderResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> AsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(AsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>> PrepareAsyncGetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>>(PrepareAsyncGetBlockHeaderByHeightRaw(context, request, cq));
    }
    ::grpc::Status GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetBlockByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByIDRaw(context, request, cq));
    }
    ::grpc::Status GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::flow::access::BlockResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> AsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(AsyncGetBlockByHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>> PrepareAsyncGetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>>(PrepareAsyncGetBlockByHeightRaw(context, request, cq));
    }
    ::grpc::Status GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::flow::access::CollectionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>> AsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>>(AsyncGetCollectionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>> PrepareAsyncGetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>>(PrepareAsyncGetCollectionByIDRaw(context, request, cq));
    }
    ::grpc::Status SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::flow::access::SendTransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>> AsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>>(AsyncSendTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>> PrepareAsyncSendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>>(PrepareAsyncSendTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>> AsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>>(AsyncGetTransactionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>> PrepareAsyncGetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>>(PrepareAsyncGetTransactionRaw(context, request, cq));
    }
    ::grpc::Status GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::flow::access::TransactionResultResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>> AsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>>(AsyncGetTransactionResultRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>> PrepareAsyncGetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>>(PrepareAsyncGetTransactionResultRaw(context, request, cq));
    }
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::flow::access::AccountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> AsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(AsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::flow::access::AccountResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> AsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(AsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>> PrepareAsyncGetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>>(PrepareAsyncGetAccountAtBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtLatestBlockRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockIDRaw(context, request, cq));
    }
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::flow::access::ExecuteScriptResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> AsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(AsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>> PrepareAsyncExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>>(PrepareAsyncExecuteScriptAtBlockHeightRaw(context, request, cq));
    }
    ::grpc::Status GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::flow::access::EventsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> AsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(AsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForHeightRangeRaw(context, request, cq));
    }
    ::grpc::Status GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::flow::access::EventsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> AsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(AsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>> PrepareAsyncGetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>>(PrepareAsyncGetEventsForBlockIDsRaw(context, request, cq));
    }
    ::grpc::Status GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::flow::access::GetNetworkParametersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>> AsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>>(AsyncGetNetworkParametersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>> PrepareAsyncGetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>>(PrepareAsyncGetNetworkParametersRaw(context, request, cq));
    }
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::flow::access::ProtocolStateSnapshotResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>> AsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>>(AsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>> PrepareAsyncGetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>>(PrepareAsyncGetLatestProtocolStateSnapshotRaw(context, request, cq));
    }
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::flow::access::ExecutionResultForBlockIdResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>> AsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>>(AsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>> PrepareAsyncGetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>>(PrepareAsyncGetExecutionResultForBlockIDRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void Ping(::grpc::ClientContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLatestBlockHeader(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeaderByID(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockHeaderByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockByID(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetBlockByHeight(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetCollectionByID(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void SendTransaction(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTransaction(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetTransactionResult(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAccountAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetAccountAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExecuteScriptAtLatestBlock(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExecuteScriptAtBlockID(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void ExecuteScriptAtBlockHeight(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEventsForHeightRange(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetEventsForBlockIDs(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetNetworkParameters(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetLatestProtocolStateSnapshot(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
      void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, std::function<void(::grpc::Status)>) override;
      #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      #else
      void GetExecutionResultForBlockID(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      #endif
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>* AsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::PingResponse>* PrepareAsyncPingRaw(::grpc::ClientContext* context, const ::flow::access::PingRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetLatestBlockHeaderRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockHeaderRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* AsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockHeaderResponse>* PrepareAsyncGetBlockHeaderByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockHeaderByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* AsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::BlockResponse>* PrepareAsyncGetBlockByHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetBlockByHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>* AsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::CollectionResponse>* PrepareAsyncGetCollectionByIDRaw(::grpc::ClientContext* context, const ::flow::access::GetCollectionByIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>* AsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::SendTransactionResponse>* PrepareAsyncSendTransactionRaw(::grpc::ClientContext* context, const ::flow::access::SendTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>* AsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResponse>* PrepareAsyncGetTransactionRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>* AsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::TransactionResultResponse>* PrepareAsyncGetTransactionResultRaw(::grpc::ClientContext* context, const ::flow::access::GetTransactionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* AsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* AsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::AccountResponse>* PrepareAsyncGetAccountAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::GetAccountAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtLatestBlockRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* AsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecuteScriptResponse>* PrepareAsyncExecuteScriptAtBlockHeightRaw(::grpc::ClientContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* AsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForHeightRangeRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForHeightRangeRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* AsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::EventsResponse>* PrepareAsyncGetEventsForBlockIDsRaw(::grpc::ClientContext* context, const ::flow::access::GetEventsForBlockIdsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>* AsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::GetNetworkParametersResponse>* PrepareAsyncGetNetworkParametersRaw(::grpc::ClientContext* context, const ::flow::access::GetNetworkParametersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>* AsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ProtocolStateSnapshotResponse>* PrepareAsyncGetLatestProtocolStateSnapshotRaw(::grpc::ClientContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>* AsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::flow::access::ExecutionResultForBlockIdResponse>* PrepareAsyncGetExecutionResultForBlockIDRaw(::grpc::ClientContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_Ping_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlockHeader_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderByID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockHeaderByHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockByID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetBlockByHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetCollectionByID_;
    const ::grpc::internal::RpcMethod rpcmethod_SendTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransaction_;
    const ::grpc::internal::RpcMethod rpcmethod_GetTransactionResult_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccountAtLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAccountAtBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtLatestBlock_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtBlockID_;
    const ::grpc::internal::RpcMethod rpcmethod_ExecuteScriptAtBlockHeight_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventsForHeightRange_;
    const ::grpc::internal::RpcMethod rpcmethod_GetEventsForBlockIDs_;
    const ::grpc::internal::RpcMethod rpcmethod_GetNetworkParameters_;
    const ::grpc::internal::RpcMethod rpcmethod_GetLatestProtocolStateSnapshot_;
    const ::grpc::internal::RpcMethod rpcmethod_GetExecutionResultForBlockID_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // *
    // The following is copied from https://docs.onflow.org/access-api/
    // You should also reference https://github.com/onflow/flow/blob/master/protobuf/flow/access/access.proto
    //
    virtual ::grpc::Status Ping(::grpc::ServerContext* context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response);
    virtual ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response);
    virtual ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response);
    virtual ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response);
    virtual ::grpc::Status GetLatestBlock(::grpc::ServerContext* context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response);
    virtual ::grpc::Status GetBlockByID(::grpc::ServerContext* context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response);
    virtual ::grpc::Status GetBlockByHeight(::grpc::ServerContext* context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response);
    virtual ::grpc::Status GetCollectionByID(::grpc::ServerContext* context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response);
    virtual ::grpc::Status SendTransaction(::grpc::ServerContext* context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response);
    virtual ::grpc::Status GetTransaction(::grpc::ServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response);
    virtual ::grpc::Status GetTransactionResult(::grpc::ServerContext* context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response);
    virtual ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response);
    virtual ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response);
    virtual ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response);
    virtual ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response);
    virtual ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response);
    virtual ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response);
    virtual ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response);
    virtual ::grpc::Status GetNetworkParameters(::grpc::ServerContext* context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response);
    virtual ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response);
    virtual ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Ping() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::flow::access::PingRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::PingResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::flow::access::GetLatestBlockHeaderRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::flow::access::GetBlockHeaderByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByHeight(::grpc::ServerContext* context, ::flow::access::GetBlockHeaderByHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockHeaderResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlock(::grpc::ServerContext* context, ::flow::access::GetLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByID(::grpc::ServerContext* context, ::flow::access::GetBlockByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByHeight(::grpc::ServerContext* context, ::flow::access::GetBlockByHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::BlockResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollectionByID(::grpc::ServerContext* context, ::flow::access::GetCollectionByIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::CollectionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_SendTransaction() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendTransaction(::grpc::ServerContext* context, ::flow::access::SendTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::SendTransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransaction() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransaction(::grpc::ServerContext* context, ::flow::access::GetTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::TransactionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::flow::access::GetTransactionRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::TransactionResultResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtLatestBlock(::grpc::ServerContext* context, ::flow::access::GetAccountAtLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::AccountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockHeight(::grpc::ServerContext* context, ::flow::access::GetAccountAtBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::AccountResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecuteScriptResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForHeightRange(::grpc::ServerContext* context, ::flow::access::GetEventsForHeightRangeRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::EventsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::flow::access::GetEventsForBlockIdsRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::EventsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParameters(::grpc::ServerContext* context, ::flow::access::GetNetworkParametersRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::GetNetworkParametersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ProtocolStateSnapshotResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionResultForBlockID(::grpc::ServerContext* context, ::flow::access::GetExecutionResultForBlockIdRequest* request, ::grpc::ServerAsyncResponseWriter< ::flow::access::ExecutionResultForBlockIdResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_Ping<WithAsyncMethod_GetLatestBlockHeader<WithAsyncMethod_GetBlockHeaderByID<WithAsyncMethod_GetBlockHeaderByHeight<WithAsyncMethod_GetLatestBlock<WithAsyncMethod_GetBlockByID<WithAsyncMethod_GetBlockByHeight<WithAsyncMethod_GetCollectionByID<WithAsyncMethod_SendTransaction<WithAsyncMethod_GetTransaction<WithAsyncMethod_GetTransactionResult<WithAsyncMethod_GetAccountAtLatestBlock<WithAsyncMethod_GetAccountAtBlockHeight<WithAsyncMethod_ExecuteScriptAtLatestBlock<WithAsyncMethod_ExecuteScriptAtBlockID<WithAsyncMethod_ExecuteScriptAtBlockHeight<WithAsyncMethod_GetEventsForHeightRange<WithAsyncMethod_GetEventsForBlockIDs<WithAsyncMethod_GetNetworkParameters<WithAsyncMethod_GetLatestProtocolStateSnapshot<WithAsyncMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Ping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::PingRequest, ::flow::access::PingResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::PingRequest* request, ::flow::access::PingResponse* response) { return this->Ping(context, request, response); }));}
    void SetMessageAllocatorFor_Ping(
        ::grpc::experimental::MessageAllocator< ::flow::access::PingRequest, ::flow::access::PingResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(0);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(0);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::PingRequest, ::flow::access::PingResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLatestBlockHeader() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetLatestBlockHeaderRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetLatestBlockHeader(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlockHeader(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(1);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHeaderByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByIdRequest, ::flow::access::BlockHeaderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetBlockHeaderByIdRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetBlockHeaderByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderByID(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetBlockHeaderByIdRequest, ::flow::access::BlockHeaderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(2);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByIdRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockHeaderByHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetBlockHeaderByHeightRequest* request, ::flow::access::BlockHeaderResponse* response) { return this->GetBlockHeaderByHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockHeaderByHeight(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(3);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetLatestBlockRequest* request, ::flow::access::BlockResponse* response) { return this->GetLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestBlock(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(4);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByIdRequest, ::flow::access::BlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetBlockByIdRequest* request, ::flow::access::BlockResponse* response) { return this->GetBlockByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockByID(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetBlockByIdRequest, ::flow::access::BlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(5);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByIdRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetBlockByHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetBlockByHeightRequest* request, ::flow::access::BlockResponse* response) { return this->GetBlockByHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetBlockByHeight(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(6);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetCollectionByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetCollectionByIdRequest, ::flow::access::CollectionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetCollectionByIdRequest* request, ::flow::access::CollectionResponse* response) { return this->GetCollectionByID(context, request, response); }));}
    void SetMessageAllocatorFor_GetCollectionByID(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetCollectionByIdRequest, ::flow::access::CollectionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(7);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetCollectionByIdRequest, ::flow::access::CollectionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCollectionByID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCollectionByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_SendTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::SendTransactionRequest* request, ::flow::access::SendTransactionResponse* response) { return this->SendTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_SendTransaction(
        ::grpc::experimental::MessageAllocator< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(8);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResponse* response) { return this->GetTransaction(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransaction(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(9);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetTransactionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetTransactionRequest* request, ::flow::access::TransactionResultResponse* response) { return this->GetTransactionResult(context, request, response); }));}
    void SetMessageAllocatorFor_GetTransactionResult(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(10);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransactionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAccountAtLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetAccountAtLatestBlockRequest* request, ::flow::access::AccountResponse* response) { return this->GetAccountAtLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccountAtLatestBlock(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(11);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAccountAtBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetAccountAtBlockHeightRequest* request, ::flow::access::AccountResponse* response) { return this->GetAccountAtBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_GetAccountAtBlockHeight(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(12);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExecuteScriptAtLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::ExecuteScriptAtLatestBlockRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtLatestBlock(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtLatestBlock(
        ::grpc::experimental::MessageAllocator< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(13);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExecuteScriptAtBlockID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockIdRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::ExecuteScriptAtBlockIdRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtBlockID(
        ::grpc::experimental::MessageAllocator< ::flow::access::ExecuteScriptAtBlockIdRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(14);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockIdRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ExecuteScriptAtBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::ExecuteScriptAtBlockHeightRequest* request, ::flow::access::ExecuteScriptResponse* response) { return this->ExecuteScriptAtBlockHeight(context, request, response); }));}
    void SetMessageAllocatorFor_ExecuteScriptAtBlockHeight(
        ::grpc::experimental::MessageAllocator< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(15);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEventsForHeightRange() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetEventsForHeightRangeRequest* request, ::flow::access::EventsResponse* response) { return this->GetEventsForHeightRange(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventsForHeightRange(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(16);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetEventsForBlockIDs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForBlockIdsRequest, ::flow::access::EventsResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetEventsForBlockIdsRequest* request, ::flow::access::EventsResponse* response) { return this->GetEventsForBlockIDs(context, request, response); }));}
    void SetMessageAllocatorFor_GetEventsForBlockIDs(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetEventsForBlockIdsRequest, ::flow::access::EventsResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(17);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetEventsForBlockIdsRequest, ::flow::access::EventsResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetNetworkParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetNetworkParametersRequest* request, ::flow::access::GetNetworkParametersResponse* response) { return this->GetNetworkParameters(context, request, response); }));}
    void SetMessageAllocatorFor_GetNetworkParameters(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(18);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetLatestProtocolStateSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetLatestProtocolStateSnapshotRequest* request, ::flow::access::ProtocolStateSnapshotResponse* response) { return this->GetLatestProtocolStateSnapshot(context, request, response); }));}
    void SetMessageAllocatorFor_GetLatestProtocolStateSnapshot(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(19);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetExecutionResultForBlockID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::flow::access::GetExecutionResultForBlockIdRequest, ::flow::access::ExecutionResultForBlockIdResponse>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::flow::access::GetExecutionResultForBlockIdRequest* request, ::flow::access::ExecutionResultForBlockIdResponse* response) { return this->GetExecutionResultForBlockID(context, request, response); }));}
    void SetMessageAllocatorFor_GetExecutionResultForBlockID(
        ::grpc::experimental::MessageAllocator< ::flow::access::GetExecutionResultForBlockIdRequest, ::flow::access::ExecutionResultForBlockIdResponse>* allocator) {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
    #else
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::experimental().GetHandler(20);
    #endif
      static_cast<::grpc::internal::CallbackUnaryHandler< ::flow::access::GetExecutionResultForBlockIdRequest, ::flow::access::ExecutionResultForBlockIdResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/)
    #endif
      { return nullptr; }
  };
  #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
  typedef ExperimentalWithCallbackMethod_Ping<ExperimentalWithCallbackMethod_GetLatestBlockHeader<ExperimentalWithCallbackMethod_GetBlockHeaderByID<ExperimentalWithCallbackMethod_GetBlockHeaderByHeight<ExperimentalWithCallbackMethod_GetLatestBlock<ExperimentalWithCallbackMethod_GetBlockByID<ExperimentalWithCallbackMethod_GetBlockByHeight<ExperimentalWithCallbackMethod_GetCollectionByID<ExperimentalWithCallbackMethod_SendTransaction<ExperimentalWithCallbackMethod_GetTransaction<ExperimentalWithCallbackMethod_GetTransactionResult<ExperimentalWithCallbackMethod_GetAccountAtLatestBlock<ExperimentalWithCallbackMethod_GetAccountAtBlockHeight<ExperimentalWithCallbackMethod_ExecuteScriptAtLatestBlock<ExperimentalWithCallbackMethod_ExecuteScriptAtBlockID<ExperimentalWithCallbackMethod_ExecuteScriptAtBlockHeight<ExperimentalWithCallbackMethod_GetEventsForHeightRange<ExperimentalWithCallbackMethod_GetEventsForBlockIDs<ExperimentalWithCallbackMethod_GetNetworkParameters<ExperimentalWithCallbackMethod_GetLatestProtocolStateSnapshot<ExperimentalWithCallbackMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > CallbackService;
  #endif

  typedef ExperimentalWithCallbackMethod_Ping<ExperimentalWithCallbackMethod_GetLatestBlockHeader<ExperimentalWithCallbackMethod_GetBlockHeaderByID<ExperimentalWithCallbackMethod_GetBlockHeaderByHeight<ExperimentalWithCallbackMethod_GetLatestBlock<ExperimentalWithCallbackMethod_GetBlockByID<ExperimentalWithCallbackMethod_GetBlockByHeight<ExperimentalWithCallbackMethod_GetCollectionByID<ExperimentalWithCallbackMethod_SendTransaction<ExperimentalWithCallbackMethod_GetTransaction<ExperimentalWithCallbackMethod_GetTransactionResult<ExperimentalWithCallbackMethod_GetAccountAtLatestBlock<ExperimentalWithCallbackMethod_GetAccountAtBlockHeight<ExperimentalWithCallbackMethod_ExecuteScriptAtLatestBlock<ExperimentalWithCallbackMethod_ExecuteScriptAtBlockID<ExperimentalWithCallbackMethod_ExecuteScriptAtBlockHeight<ExperimentalWithCallbackMethod_GetEventsForHeightRange<ExperimentalWithCallbackMethod_GetEventsForBlockIDs<ExperimentalWithCallbackMethod_GetNetworkParameters<ExperimentalWithCallbackMethod_GetLatestProtocolStateSnapshot<ExperimentalWithCallbackMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Ping() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_SendTransaction() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransaction() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Ping() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPing(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockHeaderByHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBlockByHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetCollectionByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_SendTransaction() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestSendTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransaction() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransaction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetTransactionResult(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAccountAtBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForHeightRange(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetNetworkParameters(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetExecutionResultForBlockID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Ping() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Ping(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* Ping(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* Ping(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLatestBlockHeader() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlockHeader(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestBlockHeader(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHeaderByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockHeaderByHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockHeaderByHeight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockHeaderByHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetBlockByHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetBlockByHeight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetBlockByHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetCollectionByID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetCollectionByID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetCollectionByID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetCollectionByID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_SendTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->SendTransaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* SendTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* SendTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTransaction() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransaction(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransaction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransaction(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetTransactionResult() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetTransactionResult(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetTransactionResult(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetTransactionResult(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAccountAtLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccountAtLatestBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccountAtLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAccountAtBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetAccountAtBlockHeight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetAccountAtBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExecuteScriptAtLatestBlock() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtLatestBlock(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtLatestBlock(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtBlockID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtBlockID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockHeight() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ExecuteScriptAtBlockHeight(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* ExecuteScriptAtBlockHeight(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEventsForHeightRange() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventsForHeightRange(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEventsForHeightRange(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetEventsForBlockIDs() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetEventsForBlockIDs(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetEventsForBlockIDs(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetNetworkParameters() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetNetworkParameters(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetNetworkParameters(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetLatestProtocolStateSnapshot() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetLatestProtocolStateSnapshot(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetLatestProtocolStateSnapshot(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetExecutionResultForBlockID() {
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
      ::grpc::Service::
    #else
      ::grpc::Service::experimental().
    #endif
        MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
                   ::grpc::CallbackServerContext*
    #else
                   ::grpc::experimental::CallbackServerContext*
    #endif
                     context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetExecutionResultForBlockID(context, request, response); }));
    }
    ~ExperimentalWithRawCallbackMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    #ifdef GRPC_CALLBACK_API_NONEXPERIMENTAL
    virtual ::grpc::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #else
    virtual ::grpc::experimental::ServerUnaryReactor* GetExecutionResultForBlockID(
      ::grpc::experimental::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)
    #endif
      { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Ping : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Ping() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::PingRequest, ::flow::access::PingResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::PingRequest, ::flow::access::PingResponse>* streamer) {
                       return this->StreamedPing(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Ping() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Ping(::grpc::ServerContext* /*context*/, const ::flow::access::PingRequest* /*request*/, ::flow::access::PingResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPing(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::PingRequest,::flow::access::PingResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlockHeader : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlockHeader() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestBlockHeaderRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetLatestBlockHeader(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlockHeader() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlockHeader(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockHeaderRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlockHeader(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestBlockHeaderRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderByID() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockHeaderByIdRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockHeaderByIdRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetBlockHeaderByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByIdRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockHeaderByIdRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockHeaderByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockHeaderByHeight() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockHeaderByHeightRequest, ::flow::access::BlockHeaderResponse>* streamer) {
                       return this->StreamedGetBlockHeaderByHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockHeaderByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockHeaderByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockHeaderByHeightRequest* /*request*/, ::flow::access::BlockHeaderResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockHeaderByHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockHeaderByHeightRequest,::flow::access::BlockHeaderResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestBlockRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestBlockRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestBlockRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockByID() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockByIdRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockByIdRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetBlockByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByIdRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockByIdRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetBlockByHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetBlockByHeight() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetBlockByHeightRequest, ::flow::access::BlockResponse>* streamer) {
                       return this->StreamedGetBlockByHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetBlockByHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBlockByHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetBlockByHeightRequest* /*request*/, ::flow::access::BlockResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetBlockByHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetBlockByHeightRequest,::flow::access::BlockResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetCollectionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetCollectionByID() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetCollectionByIdRequest, ::flow::access::CollectionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetCollectionByIdRequest, ::flow::access::CollectionResponse>* streamer) {
                       return this->StreamedGetCollectionByID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetCollectionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetCollectionByID(::grpc::ServerContext* /*context*/, const ::flow::access::GetCollectionByIdRequest* /*request*/, ::flow::access::CollectionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetCollectionByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetCollectionByIdRequest,::flow::access::CollectionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_SendTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_SendTransaction() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::SendTransactionRequest, ::flow::access::SendTransactionResponse>* streamer) {
                       return this->StreamedSendTransaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_SendTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status SendTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::SendTransactionRequest* /*request*/, ::flow::access::SendTransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedSendTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::SendTransactionRequest,::flow::access::SendTransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransaction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransaction() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetTransactionRequest, ::flow::access::TransactionResponse>* streamer) {
                       return this->StreamedGetTransaction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTransaction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransaction(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransaction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetTransactionRequest,::flow::access::TransactionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetTransactionResult : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetTransactionResult() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetTransactionRequest, ::flow::access::TransactionResultResponse>* streamer) {
                       return this->StreamedGetTransactionResult(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetTransactionResult() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetTransactionResult(::grpc::ServerContext* /*context*/, const ::flow::access::GetTransactionRequest* /*request*/, ::flow::access::TransactionResultResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetTransactionResult(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetTransactionRequest,::flow::access::TransactionResultResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccountAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccountAtLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetAccountAtLatestBlockRequest, ::flow::access::AccountResponse>* streamer) {
                       return this->StreamedGetAccountAtLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccountAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccountAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtLatestBlockRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccountAtLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetAccountAtLatestBlockRequest,::flow::access::AccountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAccountAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAccountAtBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetAccountAtBlockHeightRequest, ::flow::access::AccountResponse>* streamer) {
                       return this->StreamedGetAccountAtBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetAccountAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAccountAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::GetAccountAtBlockHeightRequest* /*request*/, ::flow::access::AccountResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAccountAtBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetAccountAtBlockHeightRequest,::flow::access::AccountResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtLatestBlockRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtLatestBlock(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtLatestBlock(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtLatestBlockRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtLatestBlock(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtLatestBlockRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtBlockID() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtBlockIdRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtBlockIdRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockIdRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtBlockIdRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::ExecuteScriptAtBlockHeightRequest, ::flow::access::ExecuteScriptResponse>* streamer) {
                       return this->StreamedExecuteScriptAtBlockHeight(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ExecuteScriptAtBlockHeight(::grpc::ServerContext* /*context*/, const ::flow::access::ExecuteScriptAtBlockHeightRequest* /*request*/, ::flow::access::ExecuteScriptResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedExecuteScriptAtBlockHeight(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::ExecuteScriptAtBlockHeightRequest,::flow::access::ExecuteScriptResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventsForHeightRange : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventsForHeightRange() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetEventsForHeightRangeRequest, ::flow::access::EventsResponse>* streamer) {
                       return this->StreamedGetEventsForHeightRange(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventsForHeightRange() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventsForHeightRange(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForHeightRangeRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventsForHeightRange(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetEventsForHeightRangeRequest,::flow::access::EventsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetEventsForBlockIDs : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetEventsForBlockIDs() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetEventsForBlockIdsRequest, ::flow::access::EventsResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetEventsForBlockIdsRequest, ::flow::access::EventsResponse>* streamer) {
                       return this->StreamedGetEventsForBlockIDs(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetEventsForBlockIDs() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetEventsForBlockIDs(::grpc::ServerContext* /*context*/, const ::flow::access::GetEventsForBlockIdsRequest* /*request*/, ::flow::access::EventsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetEventsForBlockIDs(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetEventsForBlockIdsRequest,::flow::access::EventsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetNetworkParameters : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetNetworkParameters() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetNetworkParametersRequest, ::flow::access::GetNetworkParametersResponse>* streamer) {
                       return this->StreamedGetNetworkParameters(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetNetworkParameters() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetNetworkParameters(::grpc::ServerContext* /*context*/, const ::flow::access::GetNetworkParametersRequest* /*request*/, ::flow::access::GetNetworkParametersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetNetworkParameters(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetNetworkParametersRequest,::flow::access::GetNetworkParametersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetLatestProtocolStateSnapshotRequest, ::flow::access::ProtocolStateSnapshotResponse>* streamer) {
                       return this->StreamedGetLatestProtocolStateSnapshot(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetLatestProtocolStateSnapshot(::grpc::ServerContext* /*context*/, const ::flow::access::GetLatestProtocolStateSnapshotRequest* /*request*/, ::flow::access::ProtocolStateSnapshotResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetLatestProtocolStateSnapshot(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetLatestProtocolStateSnapshotRequest,::flow::access::ProtocolStateSnapshotResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetExecutionResultForBlockID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetExecutionResultForBlockID() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::flow::access::GetExecutionResultForBlockIdRequest, ::flow::access::ExecutionResultForBlockIdResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::flow::access::GetExecutionResultForBlockIdRequest, ::flow::access::ExecutionResultForBlockIdResponse>* streamer) {
                       return this->StreamedGetExecutionResultForBlockID(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetExecutionResultForBlockID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetExecutionResultForBlockID(::grpc::ServerContext* /*context*/, const ::flow::access::GetExecutionResultForBlockIdRequest* /*request*/, ::flow::access::ExecutionResultForBlockIdResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetExecutionResultForBlockID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::flow::access::GetExecutionResultForBlockIdRequest,::flow::access::ExecutionResultForBlockIdResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<WithStreamedUnaryMethod_GetBlockHeaderByHeight<WithStreamedUnaryMethod_GetLatestBlock<WithStreamedUnaryMethod_GetBlockByID<WithStreamedUnaryMethod_GetBlockByHeight<WithStreamedUnaryMethod_GetCollectionByID<WithStreamedUnaryMethod_SendTransaction<WithStreamedUnaryMethod_GetTransaction<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetAccountAtLatestBlock<WithStreamedUnaryMethod_GetAccountAtBlockHeight<WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight<WithStreamedUnaryMethod_GetEventsForHeightRange<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetNetworkParameters<WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot<WithStreamedUnaryMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_Ping<WithStreamedUnaryMethod_GetLatestBlockHeader<WithStreamedUnaryMethod_GetBlockHeaderByID<WithStreamedUnaryMethod_GetBlockHeaderByHeight<WithStreamedUnaryMethod_GetLatestBlock<WithStreamedUnaryMethod_GetBlockByID<WithStreamedUnaryMethod_GetBlockByHeight<WithStreamedUnaryMethod_GetCollectionByID<WithStreamedUnaryMethod_SendTransaction<WithStreamedUnaryMethod_GetTransaction<WithStreamedUnaryMethod_GetTransactionResult<WithStreamedUnaryMethod_GetAccountAtLatestBlock<WithStreamedUnaryMethod_GetAccountAtBlockHeight<WithStreamedUnaryMethod_ExecuteScriptAtLatestBlock<WithStreamedUnaryMethod_ExecuteScriptAtBlockID<WithStreamedUnaryMethod_ExecuteScriptAtBlockHeight<WithStreamedUnaryMethod_GetEventsForHeightRange<WithStreamedUnaryMethod_GetEventsForBlockIDs<WithStreamedUnaryMethod_GetNetworkParameters<WithStreamedUnaryMethod_GetLatestProtocolStateSnapshot<WithStreamedUnaryMethod_GetExecutionResultForBlockID<Service > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace access
}  // namespace flow


#endif  // GRPC_flow_2eproto__INCLUDED
